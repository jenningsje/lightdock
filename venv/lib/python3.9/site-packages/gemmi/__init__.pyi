"""
Python bindings to GEMMI - a library used in macromolecular
crystallography and related fields
"""
from __future__ import annotations
import numpy
import pybind11_stubgen.typing_ext
import typing
from . import cif
__all__ = ['Addends', 'AlignmentResult', 'AlignmentScoring', 'Assembly', 'AssemblyList', 'AssemblySpecialKind', 'Asu', 'AsuBrick', 'Atom', 'AtomAddress', 'AtomGroup', 'AtomicRadiiSet', 'AxisOrder', 'BasicRefinementInfo', 'BatchFloats', 'BatchInts', 'Binner', 'Blob', 'BondIndex', 'BondType', 'C4322Coef', 'CRA', 'CalcFlag', 'Ccp4Base', 'Ccp4Map', 'Ccp4Mask', 'Chain', 'ChemComp', 'ChemCompAtoms', 'ChemCompMap', 'ChemLink', 'ChemLinkMap', 'ChemMod', 'ChemModMap', 'ChiralityType', 'CifToMtz', 'CifWalk', 'CisPep', 'ComplexAsuData', 'ComplexCorrelation', 'ComplexGridBase', 'ComplexHklValue', 'Connection', 'ConnectionList', 'ConnectionType', 'ContactSearch', 'CoorFileWalk', 'CoorFormat', 'Correlation', 'CraGenerator', 'CrystalInfo', 'CrystalSystem', 'DataType', 'DensityCalculatorE', 'DensityCalculatorN', 'DensityCalculatorX', 'DiffractionInfo', 'Element', 'EnerLib', 'Entity', 'EntityList', 'EntityType', 'ExperimentInfo', 'FTransform', 'FastaSeq', 'FirstConformerAtoms', 'FirstConformerRes', 'FirstConformerResSpan', 'FloatAsuData', 'FloatGrid', 'FloatGridBase', 'FloatHklValue', 'Fractional', 'FractionalBox', 'GridMeta', 'GridSizeRounding', 'GroupOps', 'GruberVector', 'Helix', 'HelixList', 'HklMatch', 'HowToNameCopiedChain', 'HydrogenChange', 'IT92Coef', 'IT92_get_exact', 'IT92_get_ignore_charge', 'IT92_normalize', 'IT92_set_ignore_charge', 'InfoMap', 'Int8Grid', 'Int8GridBase', 'IntAsuData', 'IntHklValue', 'Intensities', 'LinkHunt', 'MapSetup', 'MaskedFloatGrid', 'MaskedInt8Grid', 'Mat33', 'Metadata', 'MmcifOutputGroups', 'ModRes', 'Model', 'MonLib', 'Mtz', 'MtzBatches', 'MtzColumns', 'MtzDatasets', 'MtzToCif', 'NcsOp', 'NcsOpList', 'NearestImage', 'NeighborSearch', 'Neutron92', 'Op', 'PdbWriteOptions', 'PolymerType', 'Position', 'PositionBox', 'RKind', 'ReciprocalAsu', 'ReciprocalComplexGrid', 'ReciprocalFloatGrid', 'ReciprocalInt8Grid', 'RefinementInfo', 'ReflectionsInfo', 'ReflnBlock', 'ReflnBlocks', 'Residue', 'ResidueGroup', 'ResidueId', 'ResidueInfo', 'ResidueKind', 'ResidueSpan', 'ResidueSpanGroups', 'Restraints', 'RestraintsAngles', 'RestraintsBonds', 'RestraintsChirs', 'RestraintsPlanes', 'RestraintsTorsions', 'SMat33d', 'SMat33f', 'Scaling', 'Selection', 'SelectionAtomsProxy', 'SelectionChainsProxy', 'SelectionModelsProxy', 'SelectionResiduesProxy', 'SellingVector', 'SeqId', 'Sheet', 'SheetList', 'SmallStructure', 'SoftwareItem', 'SolventMasker', 'SpaceGroup', 'Structure', 'StructureFactorCalculatorE', 'StructureFactorCalculatorN', 'StructureFactorCalculatorX', 'SupResult', 'SupSelect', 'TlsGroup', 'Topo', 'TopoAngles', 'TopoBonds', 'TopoChainInfos', 'TopoChirs', 'TopoFinalChemComps', 'TopoLinks', 'TopoMods', 'TopoPlanes', 'TopoResInfos', 'TopoRules', 'TopoTorsions', 'Transform', 'UnitCell', 'ValueSigma', 'ValueSigmaAsuData', 'ValueSigmaHklValue', 'Vec3', 'VectorMarkPtr', 'add_automatic_links', 'add_chemcomp_to_block', 'adp_symmetry_constraints', 'align_sequence_to_polymer', 'align_string_sequences', 'as_refln_blocks', 'bessel_i1_over_i0', 'bincorr', 'binmean', 'binrfactor', 'calculate_amplitude_normalizers', 'calculate_angle', 'calculate_b_est', 'calculate_current_rmsd', 'calculate_dihedral', 'calculate_omega', 'calculate_phi_psi', 'calculate_sequence_weight', 'calculate_superposition', 'calculate_superpositions_in_moving_window', 'check_data_type_under_symmetry', 'cif', 'combine_correlations', 'count_reflections', 'cromer_liberman', 'estimate_uncompressed_size', 'expand_if_pdb_code', 'expand_ncs_model', 'expand_one_letter', 'expand_one_letter_sequence', 'expand_pdb_code_to_path', 'find_asu_brick', 'find_best_plane', 'find_blobs_by_flood_fill', 'find_lattice_2fold_ops', 'find_lattice_symmetry', 'find_lattice_symmetry_r', 'find_spacegroup_by_name', 'find_spacegroup_by_number', 'find_spacegroup_by_ops', 'find_tabulated_residue', 'find_twin_laws', 'flood_fill_above', 'generators_from_hall', 'get_distance_from_plane', 'get_spacegroup_reference_setting', 'hc', 'hkl_cif_as_refln_block', 'interpolate_grid', 'interpolate_grid_of_aligned_model2', 'is_pdb_code', 'log_bessel_i0', 'log_cosh', 'make_address', 'make_assembly', 'make_chemcomp_from_block', 'make_miller_array', 'make_small_structure_from_block', 'make_structure_from_block', 'make_structure_from_chemcomp_block', 'make_triplet_part', 'merge_atoms_in_expanded_model', 'mott_bethe_const', 'mx_to_sx_structure', 'one_letter_code', 'parse_triplet', 'parse_triplet_part', 'pdbx_one_letter_code', 'prepare_refmac_crd', 'prepare_topology', 'read_ccp4_map', 'read_ccp4_mask', 'read_monomer_lib', 'read_mtz_file', 'read_pdb', 'read_pdb_string', 'read_pir_or_fasta', 'read_small_structure', 'read_structure', 'seitz_to_op', 'sequence_kind', 'setup_for_crd', 'spacegroup_table', 'spacegroup_table_itb', 'superpose_positions', 'symops_from_hall', 'transform_f_phi_grid_to_map', 'transform_map_to_f_phi']
class Addends:
    def add_cl_fprime(self, energy: float) -> None:
        ...
    def clear(self) -> None:
        ...
    def get(self, arg0: Element) -> float:
        ...
    def set(self, arg0: Element, arg1: float) -> None:
        ...
    def subtract_z(self, except_hydrogen: bool = False) -> None:
        ...
class AlignmentResult:
    def add_gaps(self, s: str, which: int) -> str:
        ...
    def calculate_identity(self, which: int = 0) -> float:
        ...
    def cigar_str(self) -> str:
        ...
    def formatted(self, arg0: str, arg1: str) -> str:
        ...
    @property
    def match_count(self) -> int:
        ...
    @property
    def match_string(self) -> str:
        ...
    @property
    def score(self) -> int:
        ...
class AlignmentScoring:
    bad_gapo: int
    gape: int
    gapo: int
    good_gapo: int
    match: int
    mismatch: int
    def __init__(self, what: str = 's') -> None:
        ...
class Assembly:
    class Gen:
        chains: list[str]
        subchains: list[str]
        def __init__(self) -> None:
            ...
        @property
        def operators(self) -> Assembly.OperatorList:
            ...
    class GenList:
        def __bool__(self) -> bool:
            """
            Check whether the list is nonempty
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None:
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None:
            """
            Delete list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, s: slice) -> Assembly.GenList:
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> Assembly.Gen:
            ...
        @typing.overload
        def __init__(self) -> None:
            ...
        @typing.overload
        def __init__(self, arg0: Assembly.GenList) -> None:
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None:
            ...
        def __iter__(self) -> typing.Iterator:
            ...
        def __len__(self) -> int:
            ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: Assembly.Gen) -> None:
            ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: Assembly.GenList) -> None:
            """
            Assign list elements using a slice object
            """
        def append(self, x: Assembly.Gen) -> None:
            """
            Add an item to the end of the list
            """
        def clear(self) -> None:
            """
            Clear the contents
            """
        @typing.overload
        def extend(self, L: Assembly.GenList) -> None:
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None:
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: Assembly.Gen) -> None:
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> Assembly.Gen:
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> Assembly.Gen:
            """
            Remove and return the item at index ``i``
            """
    class Operator:
        name: str
        transform: Transform
        type: str
        def __init__(self) -> None:
            ...
    class OperatorList:
        def __bool__(self) -> bool:
            """
            Check whether the list is nonempty
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None:
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None:
            """
            Delete list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, s: slice) -> Assembly.OperatorList:
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> Assembly.Operator:
            ...
        @typing.overload
        def __init__(self) -> None:
            ...
        @typing.overload
        def __init__(self, arg0: Assembly.OperatorList) -> None:
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None:
            ...
        def __iter__(self) -> typing.Iterator:
            ...
        def __len__(self) -> int:
            ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: Assembly.Operator) -> None:
            ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: Assembly.OperatorList) -> None:
            """
            Assign list elements using a slice object
            """
        def append(self, x: Assembly.Operator) -> None:
            """
            Add an item to the end of the list
            """
        def clear(self) -> None:
            """
            Clear the contents
            """
        @typing.overload
        def extend(self, L: Assembly.OperatorList) -> None:
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None:
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: Assembly.Operator) -> None:
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> Assembly.Operator:
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> Assembly.Operator:
            """
            Remove and return the item at index ``i``
            """
    author_determined: bool
    name: str
    oligomeric_details: str
    software_determined: bool
    special_kind: AssemblySpecialKind
    def __init__(self, arg0: str) -> None:
        ...
    @property
    def generators(self) -> Assembly.GenList:
        ...
class AssemblyList:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> AssemblyList:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Assembly:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: AssemblyList) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Assembly) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: AssemblyList) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Assembly) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: AssemblyList) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Assembly) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Assembly:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Assembly:
        """
        Remove and return the item at index ``i``
        """
class AssemblySpecialKind:
    """
    Members:
    
      NA
    
      CompleteIcosahedral
    
      RepresentativeHelical
    
      CompletePoint
    """
    CompleteIcosahedral: typing.ClassVar[AssemblySpecialKind]  # value = <AssemblySpecialKind.CompleteIcosahedral: 1>
    CompletePoint: typing.ClassVar[AssemblySpecialKind]  # value = <AssemblySpecialKind.CompletePoint: 3>
    NA: typing.ClassVar[AssemblySpecialKind]  # value = <AssemblySpecialKind.NA: 0>
    RepresentativeHelical: typing.ClassVar[AssemblySpecialKind]  # value = <AssemblySpecialKind.RepresentativeHelical: 2>
    __members__: typing.ClassVar[dict[str, AssemblySpecialKind]]  # value = {'NA': <AssemblySpecialKind.NA: 0>, 'CompleteIcosahedral': <AssemblySpecialKind.CompleteIcosahedral: 1>, 'RepresentativeHelical': <AssemblySpecialKind.RepresentativeHelical: 2>, 'CompletePoint': <AssemblySpecialKind.CompletePoint: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Asu:
    """
    Members:
    
      Same
    
      Different
    
      Any
    """
    Any: typing.ClassVar[Asu]  # value = <Asu.Any: 2>
    Different: typing.ClassVar[Asu]  # value = <Asu.Different: 1>
    Same: typing.ClassVar[Asu]  # value = <Asu.Same: 0>
    __members__: typing.ClassVar[dict[str, Asu]]  # value = {'Same': <Asu.Same: 0>, 'Different': <Asu.Different: 1>, 'Any': <Asu.Any: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class AsuBrick:
    def get_extent(self) -> FractionalBox:
        ...
    def str(self) -> str:
        ...
    @property
    def incl(self) -> typing.Annotated[list[bool], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    @property
    def size(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
class Atom:
    altloc: str
    aniso: SMat33f
    b_iso: float
    calc_flag: CalcFlag
    charge: int
    element: Element
    flag: str
    fraction: float
    name: str
    occ: float
    pos: Position
    serial: int
    tls_group_id: int
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def b_eq(self) -> float:
        ...
    def clone(self) -> Atom:
        ...
    def has_altloc(self) -> bool:
        ...
    def is_hydrogen(self) -> bool:
        ...
    def padded_name(self) -> str:
        ...
class AtomAddress:
    __hash__: typing.ClassVar[None] = None
    altloc: str
    atom_name: str
    chain_name: str
    res_id: ResidueId
    def __eq__(self, arg0: AtomAddress) -> bool:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, chain: str, seqid: SeqId, resname: str, atom: str, altloc: str = '\x00') -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def __str__(self) -> str:
        ...
class AtomGroup:
    def __bool__(self) -> bool:
        ...
    @typing.overload
    def __getitem__(self, index: int) -> Atom:
        ...
    @typing.overload
    def __getitem__(self, altloc: str) -> Atom:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def name(self) -> str:
        ...
class AtomicRadiiSet:
    """
    Members:
    
      VanDerWaals
    
      Cctbx
    
      Refmac
    
      Constant
    """
    Cctbx: typing.ClassVar[AtomicRadiiSet]  # value = <AtomicRadiiSet.Cctbx: 1>
    Constant: typing.ClassVar[AtomicRadiiSet]  # value = <AtomicRadiiSet.Constant: 3>
    Refmac: typing.ClassVar[AtomicRadiiSet]  # value = <AtomicRadiiSet.Refmac: 2>
    VanDerWaals: typing.ClassVar[AtomicRadiiSet]  # value = <AtomicRadiiSet.VanDerWaals: 0>
    __members__: typing.ClassVar[dict[str, AtomicRadiiSet]]  # value = {'VanDerWaals': <AtomicRadiiSet.VanDerWaals: 0>, 'Cctbx': <AtomicRadiiSet.Cctbx: 1>, 'Refmac': <AtomicRadiiSet.Refmac: 2>, 'Constant': <AtomicRadiiSet.Constant: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class AxisOrder:
    """
    Members:
    
      Unknown
    
      XYZ
    
      ZYX
    """
    Unknown: typing.ClassVar[AxisOrder]  # value = <AxisOrder.Unknown: 0>
    XYZ: typing.ClassVar[AxisOrder]  # value = <AxisOrder.XYZ: 1>
    ZYX: typing.ClassVar[AxisOrder]  # value = <AxisOrder.ZYX: 2>
    __members__: typing.ClassVar[dict[str, AxisOrder]]  # value = {'Unknown': <AxisOrder.Unknown: 0>, 'XYZ': <AxisOrder.XYZ: 1>, 'ZYX': <AxisOrder.ZYX: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class BasicRefinementInfo:
    completeness: float
    r_all: float
    r_free: float
    r_work: float
    reflection_count: int
    resolution_high: float
    resolution_low: float
    rfree_set_count: int
    def __init__(self) -> None:
        ...
class BatchFloats:
    def __getitem__(self, arg0: int) -> float:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
class BatchInts:
    def __getitem__(self, arg0: int) -> int:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: int, arg1: int) -> None:
        ...
class Binner:
    class Method:
        """
        Members:
        
          EqualCount
        
          Dstar
        
          Dstar2
        
          Dstar3
        """
        Dstar: typing.ClassVar[Binner.Method]  # value = <Method.Dstar: 1>
        Dstar2: typing.ClassVar[Binner.Method]  # value = <Method.Dstar2: 2>
        Dstar3: typing.ClassVar[Binner.Method]  # value = <Method.Dstar3: 3>
        EqualCount: typing.ClassVar[Binner.Method]  # value = <Method.EqualCount: 0>
        __members__: typing.ClassVar[dict[str, Binner.Method]]  # value = {'EqualCount': <Method.EqualCount: 0>, 'Dstar': <Method.Dstar: 1>, 'Dstar2': <Method.Dstar2: 2>, 'Dstar3': <Method.Dstar3: 3>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    cell: UnitCell
    def __init__(self) -> None:
        ...
    def dmax_of_bin(self, arg0: int) -> float:
        ...
    def dmin_of_bin(self, arg0: int) -> float:
        ...
    def get_bin(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> int:
        ...
    @typing.overload
    def get_bins(self, arg0: Mtz) -> numpy.ndarray:
        ...
    @typing.overload
    def get_bins(self, arg0: ReflnBlock) -> numpy.ndarray:
        ...
    @typing.overload
    def get_bins(self, arg0: numpy.ndarray) -> numpy.ndarray:
        ...
    def get_bins_from_1_d2(self, arg0: numpy.ndarray) -> numpy.ndarray:
        ...
    @typing.overload
    def setup(self, nbins: int, method: Binner.Method, mtz: Mtz, cell: UnitCell = None) -> None:
        ...
    @typing.overload
    def setup(self, nbins: int, method: Binner.Method, r: ReflnBlock, cell: UnitCell = None) -> None:
        ...
    @typing.overload
    def setup(self, nbins: int, method: Binner.Method, hkl: numpy.ndarray, cell: UnitCell) -> None:
        ...
    def setup_from_1_d2(self, nbins: int, method: Binner.Method, inv_d2: numpy.ndarray, cell: UnitCell) -> None:
        ...
    @property
    def limits(self) -> list[float]:
        ...
    @property
    def max_1_d2(self) -> float:
        ...
    @property
    def min_1_d2(self) -> float:
        ...
    @property
    def size(self) -> int:
        ...
class Blob:
    @property
    def centroid(self) -> Position:
        ...
    @property
    def peak_pos(self) -> Position:
        ...
    @property
    def peak_value(self) -> float:
        ...
    @property
    def score(self) -> float:
        ...
    @property
    def volume(self) -> float:
        ...
class BondIndex:
    def __init__(self, arg0: Model) -> None:
        ...
    def add_link(self, arg0: Atom, arg1: Atom, arg2: bool) -> None:
        ...
    def add_monomer_bonds(self, arg0: MonLib) -> None:
        ...
    def are_linked(self, arg0: Atom, arg1: Atom, arg2: bool) -> bool:
        ...
    def graph_distance(self, a: Atom, b: Atom, same_index: bool, max_distance: int = 4) -> int:
        ...
class BondType:
    """
    Members:
    
      Unspec
    
      Single
    
      Double
    
      Triple
    
      Aromatic
    
      Deloc
    
      Metal
    """
    Aromatic: typing.ClassVar[BondType]  # value = <BondType.Aromatic: 4>
    Deloc: typing.ClassVar[BondType]  # value = <BondType.Deloc: 5>
    Double: typing.ClassVar[BondType]  # value = <BondType.Double: 2>
    Metal: typing.ClassVar[BondType]  # value = <BondType.Metal: 6>
    Single: typing.ClassVar[BondType]  # value = <BondType.Single: 1>
    Triple: typing.ClassVar[BondType]  # value = <BondType.Triple: 3>
    Unspec: typing.ClassVar[BondType]  # value = <BondType.Unspec: 0>
    __members__: typing.ClassVar[dict[str, BondType]]  # value = {'Unspec': <BondType.Unspec: 0>, 'Single': <BondType.Single: 1>, 'Double': <BondType.Double: 2>, 'Triple': <BondType.Triple: 3>, 'Aromatic': <BondType.Aromatic: 4>, 'Deloc': <BondType.Deloc: 5>, 'Metal': <BondType.Metal: 6>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class C4322Coef:
    def calculate_density_iso(self, r2: float, B: float) -> float:
        ...
    def calculate_sf(self, stol2: float) -> float:
        ...
    def get_coefs(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(10)]:
        ...
    def set_coefs(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(10)]) -> None:
        ...
    @property
    def a(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(5)]:
        ...
    @property
    def b(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(5)]:
        ...
class CRA:
    def __repr__(self) -> str:
        ...
    def __str__(self) -> str:
        ...
    def atom_matches(self, arg0: AtomAddress) -> bool:
        ...
    @property
    def atom(self) -> Atom:
        ...
    @property
    def chain(self) -> Chain:
        ...
    @property
    def residue(self) -> Residue:
        ...
class CalcFlag:
    """
    Members:
    
      NotSet
    
      NoHydrogen
    
      Determined
    
      Calculated
    
      Dummy
    """
    Calculated: typing.ClassVar[CalcFlag]  # value = <CalcFlag.Calculated: 3>
    Determined: typing.ClassVar[CalcFlag]  # value = <CalcFlag.Determined: 2>
    Dummy: typing.ClassVar[CalcFlag]  # value = <CalcFlag.Dummy: 4>
    NoHydrogen: typing.ClassVar[CalcFlag]  # value = <CalcFlag.NoHydrogen: 1>
    NotSet: typing.ClassVar[CalcFlag]  # value = <CalcFlag.NotSet: 0>
    __members__: typing.ClassVar[dict[str, CalcFlag]]  # value = {'NotSet': <CalcFlag.NotSet: 0>, 'NoHydrogen': <CalcFlag.NoHydrogen: 1>, 'Determined': <CalcFlag.Determined: 2>, 'Calculated': <CalcFlag.Calculated: 3>, 'Dummy': <CalcFlag.Dummy: 4>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Ccp4Base:
    def axis_positions(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def get_extent(self) -> FractionalBox:
        ...
    def get_skew_transformation(self) -> Transform:
        ...
    def has_skew_transformation(self) -> bool:
        ...
    def header_float(self, arg0: int) -> float:
        ...
    def header_i32(self, arg0: int) -> int:
        ...
    def header_str(self, w: int, len: int = 80) -> str:
        ...
    def set_header_float(self, arg0: int, arg1: float) -> None:
        ...
    def set_header_i32(self, arg0: int, arg1: int) -> None:
        ...
    def set_header_str(self, arg0: int, arg1: str) -> None:
        ...
class Ccp4Map(Ccp4Base):
    grid: FloatGrid
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def full_cell(self) -> bool:
        ...
    def set_extent(self, arg0: FractionalBox) -> None:
        ...
    def setup(self, default_value: float, mode: MapSetup = MapSetup.Full) -> None:
        ...
    def update_ccp4_header(self, mode: int = -1, update_stats: bool = True) -> None:
        ...
    def write_ccp4_map(self, filename: str) -> None:
        ...
class Ccp4Mask(Ccp4Base):
    grid: Int8Grid
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def full_cell(self) -> bool:
        ...
    def set_extent(self, arg0: FractionalBox) -> None:
        ...
    def setup(self, default_value: int, mode: MapSetup = MapSetup.Full) -> None:
        ...
    def update_ccp4_header(self, mode: int = -1, update_stats: bool = True) -> None:
        ...
    def write_ccp4_map(self, filename: str) -> None:
        ...
class Chain:
    name: str
    @typing.overload
    def __delitem__(self, index: int) -> None:
        ...
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        ...
    @typing.overload
    def __getitem__(self, pdb_seqid: str) -> ResidueGroup:
        ...
    @typing.overload
    def __getitem__(self, index: int) -> Residue:
        ...
    @typing.overload
    def __getitem__(self, arg0: slice) -> list:
        ...
    def __init__(self, arg0: str) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def add_residue(self, residue: Residue, pos: int = -1) -> Residue:
        ...
    def append_residues(self, new_residues: list[Residue], min_sep: int = 0) -> None:
        ...
    def calculate_center_of_mass(self) -> Position:
        ...
    def calculate_mass(self) -> float:
        ...
    def clone(self) -> Chain:
        ...
    def count_atom_sites(self, sel: Selection = None) -> int:
        ...
    def count_occupancies(self, sel: Selection = None) -> float:
        ...
    def first_conformer(self) -> FirstConformerRes:
        ...
    def get_ligands(self) -> ResidueSpan:
        ...
    def get_polymer(self) -> ResidueSpan:
        ...
    def get_subchain(self, arg0: str) -> ResidueSpan:
        ...
    def get_waters(self) -> ResidueSpan:
        ...
    def next_residue(self, arg0: Residue) -> Residue:
        ...
    def previous_residue(self, arg0: Residue) -> Residue:
        ...
    def subchains(self) -> list[ResidueSpan]:
        ...
    def trim_to_alanine(self) -> None:
        ...
    def whole(self) -> ResidueSpan:
        ...
class ChemComp:
    class Aliasing:
        def name_from_alias(self, arg0: str) -> str:
            ...
        @property
        def group(self) -> ChemComp.Group:
            ...
    class Atom:
        def is_hydrogen(self) -> bool:
            ...
        @property
        def charge(self) -> float:
            ...
        @property
        def chem_type(self) -> str:
            ...
        @property
        def el(self) -> Element:
            ...
        @property
        def id(self) -> str:
            ...
    class Group:
        """
        Members:
        
          Peptide
        
          PPeptide
        
          MPeptide
        
          Dna
        
          Rna
        
          DnaRna
        
          Pyranose
        
          Ketopyranose
        
          Furanose
        
          NonPolymer
        
          Null
        """
        Dna: typing.ClassVar[ChemComp.Group]  # value = <Group.Dna: 3>
        DnaRna: typing.ClassVar[ChemComp.Group]  # value = <Group.DnaRna: 5>
        Furanose: typing.ClassVar[ChemComp.Group]  # value = <Group.Furanose: 8>
        Ketopyranose: typing.ClassVar[ChemComp.Group]  # value = <Group.Ketopyranose: 7>
        MPeptide: typing.ClassVar[ChemComp.Group]  # value = <Group.MPeptide: 2>
        NonPolymer: typing.ClassVar[ChemComp.Group]  # value = <Group.NonPolymer: 9>
        Null: typing.ClassVar[ChemComp.Group]  # value = <Group.Null: 10>
        PPeptide: typing.ClassVar[ChemComp.Group]  # value = <Group.PPeptide: 1>
        Peptide: typing.ClassVar[ChemComp.Group]  # value = <Group.Peptide: 0>
        Pyranose: typing.ClassVar[ChemComp.Group]  # value = <Group.Pyranose: 6>
        Rna: typing.ClassVar[ChemComp.Group]  # value = <Group.Rna: 4>
        __members__: typing.ClassVar[dict[str, ChemComp.Group]]  # value = {'Peptide': <Group.Peptide: 0>, 'PPeptide': <Group.PPeptide: 1>, 'MPeptide': <Group.MPeptide: 2>, 'Dna': <Group.Dna: 3>, 'Rna': <Group.Rna: 4>, 'DnaRna': <Group.DnaRna: 5>, 'Pyranose': <Group.Pyranose: 6>, 'Ketopyranose': <Group.Ketopyranose: 7>, 'Furanose': <Group.Furanose: 8>, 'NonPolymer': <Group.NonPolymer: 9>, 'Null': <Group.Null: 10>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    group: ChemComp.Group
    name: str
    @staticmethod
    def group_str(arg0: ChemComp.Group) -> str:
        ...
    def find_atom(self, arg0: str) -> ChemComp.Atom:
        ...
    def get_atom(self, arg0: str) -> ChemComp.Atom:
        ...
    def remove_hydrogens(self) -> ChemComp:
        ...
    def set_group(self, arg0: str) -> None:
        ...
    @property
    def atoms(self) -> ChemCompAtoms:
        ...
    @property
    def rt(self) -> Restraints:
        ...
class ChemCompAtoms:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> ChemCompAtoms:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> ChemComp.Atom:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ChemCompAtoms) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: ChemComp.Atom) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: ChemCompAtoms) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: ChemComp.Atom) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: ChemCompAtoms) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: ChemComp.Atom) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> ChemComp.Atom:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> ChemComp.Atom:
        """
        Remove and return the item at index ``i``
        """
class ChemCompMap:
    def __bool__(self) -> bool:
        """
        Check whether the map is nonempty
        """
    @typing.overload
    def __contains__(self, arg0: str) -> bool:
        ...
    @typing.overload
    def __contains__(self, arg0: typing.Any) -> bool:
        ...
    def __delitem__(self, arg0: str) -> None:
        ...
    def __getitem__(self, arg0: str) -> ChemComp:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: str, arg1: ChemComp) -> None:
        ...
    def items(self) -> typing.ItemsView[str, ChemComp]:
        ...
    def keys(self) -> typing.KeysView[str]:
        ...
    def values(self) -> typing.ValuesView[ChemComp]:
        ...
class ChemLink:
    class Side:
        comp: str
        group: ChemComp.Group
        mod: str
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
    id: str
    name: str
    rt: Restraints
    side1: ChemLink.Side
    side2: ChemLink.Side
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class ChemLinkMap:
    def __bool__(self) -> bool:
        """
        Check whether the map is nonempty
        """
    @typing.overload
    def __contains__(self, arg0: str) -> bool:
        ...
    @typing.overload
    def __contains__(self, arg0: typing.Any) -> bool:
        ...
    def __delitem__(self, arg0: str) -> None:
        ...
    def __getitem__(self, arg0: str) -> ChemLink:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: str, arg1: ChemLink) -> None:
        ...
    def items(self) -> typing.ItemsView[str, ChemLink]:
        ...
    def keys(self) -> typing.KeysView[str]:
        ...
    def values(self) -> typing.ValuesView[ChemLink]:
        ...
class ChemMod:
    class AtomMod:
        charge: float
        chem_type: str
        el: Element
        func: int
        new_id: str
        old_id: str
    atom_mods: list[ChemMod.AtomMod]
    comp_id: str
    group_id: str
    id: str
    name: str
    rt: Restraints
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class ChemModMap:
    def __bool__(self) -> bool:
        """
        Check whether the map is nonempty
        """
    @typing.overload
    def __contains__(self, arg0: str) -> bool:
        ...
    @typing.overload
    def __contains__(self, arg0: typing.Any) -> bool:
        ...
    def __delitem__(self, arg0: str) -> None:
        ...
    def __getitem__(self, arg0: str) -> ChemMod:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __setitem__(self, arg0: str, arg1: ChemMod) -> None:
        ...
    def items(self) -> typing.ItemsView[str, ChemMod]:
        ...
    def keys(self) -> typing.KeysView[str]:
        ...
    def values(self) -> typing.ValuesView[ChemMod]:
        ...
class ChiralityType:
    """
    Members:
    
      Positive
    
      Negative
    
      Both
    """
    Both: typing.ClassVar[ChiralityType]  # value = <ChiralityType.Both: 2>
    Negative: typing.ClassVar[ChiralityType]  # value = <ChiralityType.Negative: 1>
    Positive: typing.ClassVar[ChiralityType]  # value = <ChiralityType.Positive: 0>
    __members__: typing.ClassVar[dict[str, ChiralityType]]  # value = {'Positive': <ChiralityType.Positive: 0>, 'Negative': <ChiralityType.Negative: 1>, 'Both': <ChiralityType.Both: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class CifToMtz:
    history: list[str]
    spec_lines: list[str]
    title: str
    def __init__(self) -> None:
        ...
    def convert_block_to_mtz(self, arg0: ReflnBlock) -> Mtz:
        ...
class CifWalk:
    def __init__(self, path: str, try_pdbid: str = '\x00') -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
class CisPep:
    model_str: str
    only_altloc: str
    partner_c: AtomAddress
    partner_n: AtomAddress
    reported_angle: float
    def __init__(self) -> None:
        ...
class ComplexAsuData:
    spacegroup: SpaceGroup
    unit_cell: UnitCell
    def __getitem__(self, index: int) -> ComplexHklValue:
        ...
    def __init__(self, cell: UnitCell, sg: SpaceGroup, miller_array: numpy.ndarray, value_array: numpy.ndarray) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def calculate_correlation(self, arg0: ComplexAsuData) -> ComplexCorrelation:
        ...
    def copy(self) -> ComplexAsuData:
        ...
    def count_equal_values(self, arg0: ComplexAsuData) -> int:
        ...
    def data_fits_into(self, size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> bool:
        ...
    def ensure_asu(self, tnt_asu: bool = False) -> None:
        ...
    def ensure_sorted(self) -> None:
        ...
    def get_f_phi_on_grid(self, size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)], half_l: bool = False, order: AxisOrder = AxisOrder.XYZ) -> ReciprocalComplexGrid:
        ...
    def get_size_for_hkl(self, min_size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] = [0, 0, 0], sample_rate: float = 0.0) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def make_1_d2_array(self) -> numpy.ndarray:
        ...
    def make_d_array(self) -> numpy.ndarray:
        ...
    def transform_f_phi_to_map(self, min_size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] = [0, 0, 0], sample_rate: float = 0.0, exact_size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] = [0, 0, 0], order: AxisOrder = AxisOrder.XYZ) -> FloatGrid:
        ...
    @property
    def miller_array(self) -> numpy.ndarray:
        ...
    @property
    def value_array(self) -> numpy.ndarray:
        ...
class ComplexCorrelation:
    def coefficient(self) -> complex:
        ...
    def mean_ratio(self) -> float:
        ...
    @property
    def n(self) -> int:
        ...
class ComplexGridBase(GridMeta):
    class Point:
        value: complex
        def __repr__(self) -> str:
            ...
        @property
        def u(self) -> int:
            ...
        @property
        def v(self) -> int:
            ...
        @property
        def w(self) -> int:
            ...
    def __iter__(self) -> typing.Iterator:
        ...
    def fill(self, value: complex) -> None:
        ...
    def index_to_point(self, arg0: int) -> ComplexGridBase.Point:
        ...
    def point_to_index(self, arg0: ComplexGridBase.Point) -> int:
        ...
    def sum(self) -> complex:
        ...
    @property
    def array(self) -> numpy.ndarray:
        ...
class ComplexHklValue:
    value: complex
    def __repr__(self) -> str:
        ...
    @property
    def hkl(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
class Connection:
    asu: Asu
    link_id: str
    name: str
    partner1: AtomAddress
    partner2: AtomAddress
    reported_distance: float
    type: ConnectionType
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
class ConnectionList:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> ConnectionList:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Connection:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: ConnectionList) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Connection) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: ConnectionList) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Connection) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: ConnectionList) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Connection) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Connection:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Connection:
        """
        Remove and return the item at index ``i``
        """
class ConnectionType:
    """
    Members:
    
      Covale
    
      Disulf
    
      Hydrog
    
      MetalC
    
      Unknown
    """
    Covale: typing.ClassVar[ConnectionType]  # value = <ConnectionType.Covale: 0>
    Disulf: typing.ClassVar[ConnectionType]  # value = <ConnectionType.Disulf: 1>
    Hydrog: typing.ClassVar[ConnectionType]  # value = <ConnectionType.Hydrog: 2>
    MetalC: typing.ClassVar[ConnectionType]  # value = <ConnectionType.MetalC: 3>
    Unknown: typing.ClassVar[ConnectionType]  # value = <ConnectionType.Unknown: 4>
    __members__: typing.ClassVar[dict[str, ConnectionType]]  # value = {'Covale': <ConnectionType.Covale: 0>, 'Disulf': <ConnectionType.Disulf: 1>, 'Hydrog': <ConnectionType.Hydrog: 2>, 'MetalC': <ConnectionType.MetalC: 3>, 'Unknown': <ConnectionType.Unknown: 4>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ContactSearch:
    class Ignore:
        """
        Members:
        
          Nothing
        
          SameResidue
        
          AdjacentResidues
        
          SameChain
        
          SameAsu
        """
        AdjacentResidues: typing.ClassVar[ContactSearch.Ignore]  # value = <Ignore.AdjacentResidues: 2>
        Nothing: typing.ClassVar[ContactSearch.Ignore]  # value = <Ignore.Nothing: 0>
        SameAsu: typing.ClassVar[ContactSearch.Ignore]  # value = <Ignore.SameAsu: 4>
        SameChain: typing.ClassVar[ContactSearch.Ignore]  # value = <Ignore.SameChain: 3>
        SameResidue: typing.ClassVar[ContactSearch.Ignore]  # value = <Ignore.SameResidue: 1>
        __members__: typing.ClassVar[dict[str, ContactSearch.Ignore]]  # value = {'Nothing': <Ignore.Nothing: 0>, 'SameResidue': <Ignore.SameResidue: 1>, 'AdjacentResidues': <Ignore.AdjacentResidues: 2>, 'SameChain': <Ignore.SameChain: 3>, 'SameAsu': <Ignore.SameAsu: 4>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class Result:
        @property
        def dist(self) -> float:
            ...
        @property
        def image_idx(self) -> int:
            ...
        @property
        def partner1(self) -> CRA:
            ...
        @property
        def partner2(self) -> CRA:
            ...
    ignore: ContactSearch.Ignore
    min_occupancy: float
    search_radius: float
    special_pos_cutoff_sq: float
    twice: bool
    def __init__(self, arg0: float) -> None:
        ...
    def find_contacts(self, arg0: NeighborSearch) -> list[ContactSearch.Result]:
        ...
    def get_radius(self, arg0: Element) -> float:
        ...
    def set_radius(self, arg0: Element, arg1: float) -> None:
        ...
    def setup_atomic_radii(self, arg0: float, arg1: float) -> None:
        ...
class CoorFileWalk:
    def __init__(self, path: str, try_pdbid: str = '\x00') -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
class CoorFormat:
    """
    Members:
    
      Unknown
    
      Detect
    
      Pdb
    
      Mmcif
    
      Mmjson
    
      ChemComp
    """
    ChemComp: typing.ClassVar[CoorFormat]  # value = <CoorFormat.ChemComp: 5>
    Detect: typing.ClassVar[CoorFormat]  # value = <CoorFormat.Detect: 1>
    Mmcif: typing.ClassVar[CoorFormat]  # value = <CoorFormat.Mmcif: 3>
    Mmjson: typing.ClassVar[CoorFormat]  # value = <CoorFormat.Mmjson: 4>
    Pdb: typing.ClassVar[CoorFormat]  # value = <CoorFormat.Pdb: 2>
    Unknown: typing.ClassVar[CoorFormat]  # value = <CoorFormat.Unknown: 0>
    __members__: typing.ClassVar[dict[str, CoorFormat]]  # value = {'Unknown': <CoorFormat.Unknown: 0>, 'Detect': <CoorFormat.Detect: 1>, 'Pdb': <CoorFormat.Pdb: 2>, 'Mmcif': <CoorFormat.Mmcif: 3>, 'Mmjson': <CoorFormat.Mmjson: 4>, 'ChemComp': <CoorFormat.ChemComp: 5>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Correlation:
    def coefficient(self) -> float:
        ...
    def mean_ratio(self) -> float:
        ...
    @property
    def n(self) -> int:
        ...
class CraGenerator:
    def __iter__(self) -> typing.Iterator:
        ...
class CrystalInfo:
    description: str
    diffractions: list[DiffractionInfo]
    id: str
    ph: float
    ph_range: str
    def __init__(self) -> None:
        ...
class CrystalSystem:
    """
    Members:
    
      Triclinic
    
      Monoclinic
    
      Orthorhombic
    
      Tetragonal
    
      Trigonal
    
      Hexagonal
    
      Cubic
    """
    Cubic: typing.ClassVar[CrystalSystem]  # value = <CrystalSystem.Cubic: 6>
    Hexagonal: typing.ClassVar[CrystalSystem]  # value = <CrystalSystem.Hexagonal: 5>
    Monoclinic: typing.ClassVar[CrystalSystem]  # value = <CrystalSystem.Monoclinic: 1>
    Orthorhombic: typing.ClassVar[CrystalSystem]  # value = <CrystalSystem.Orthorhombic: 2>
    Tetragonal: typing.ClassVar[CrystalSystem]  # value = <CrystalSystem.Tetragonal: 3>
    Triclinic: typing.ClassVar[CrystalSystem]  # value = <CrystalSystem.Triclinic: 0>
    Trigonal: typing.ClassVar[CrystalSystem]  # value = <CrystalSystem.Trigonal: 4>
    __members__: typing.ClassVar[dict[str, CrystalSystem]]  # value = {'Triclinic': <CrystalSystem.Triclinic: 0>, 'Monoclinic': <CrystalSystem.Monoclinic: 1>, 'Orthorhombic': <CrystalSystem.Orthorhombic: 2>, 'Tetragonal': <CrystalSystem.Tetragonal: 3>, 'Trigonal': <CrystalSystem.Trigonal: 4>, 'Hexagonal': <CrystalSystem.Hexagonal: 5>, 'Cubic': <CrystalSystem.Cubic: 6>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class DataType:
    """
    Members:
    
      Unknown
    
      Unmerged
    
      Mean
    
      Anomalous
    """
    Anomalous: typing.ClassVar[DataType]  # value = <DataType.Anomalous: 3>
    Mean: typing.ClassVar[DataType]  # value = <DataType.Mean: 2>
    Unknown: typing.ClassVar[DataType]  # value = <DataType.Unknown: 0>
    Unmerged: typing.ClassVar[DataType]  # value = <DataType.Unmerged: 1>
    __members__: typing.ClassVar[dict[str, DataType]]  # value = {'Unknown': <DataType.Unknown: 0>, 'Unmerged': <DataType.Unmerged: 1>, 'Mean': <DataType.Mean: 2>, 'Anomalous': <DataType.Anomalous: 3>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class DensityCalculatorE:
    addends: Addends
    blur: float
    cutoff: float
    d_min: float
    rate: float
    def __init__(self) -> None:
        ...
    def add_atom_density_to_grid(self, arg0: Atom) -> None:
        ...
    def add_c_contribution_to_grid(self, arg0: Atom, arg1: float) -> None:
        ...
    def add_model_density_to_grid(self, arg0: Model) -> None:
        ...
    def estimate_radius(self, arg0: Atom) -> float:
        ...
    def initialize_grid(self) -> None:
        ...
    def mott_bethe_factor(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> float:
        ...
    def put_model_density_on_grid(self, arg0: Model) -> None:
        ...
    def reciprocal_space_multiplier(self, arg0: float) -> float:
        ...
    def set_grid_cell_and_spacegroup(self, arg0: Structure) -> None:
        ...
    def set_refmac_compatible_blur(self, arg0: Model) -> None:
        ...
    @property
    def grid(self) -> FloatGrid:
        ...
class DensityCalculatorN:
    addends: Addends
    blur: float
    cutoff: float
    d_min: float
    rate: float
    def __init__(self) -> None:
        ...
    def add_atom_density_to_grid(self, arg0: Atom) -> None:
        ...
    def add_c_contribution_to_grid(self, arg0: Atom, arg1: float) -> None:
        ...
    def add_model_density_to_grid(self, arg0: Model) -> None:
        ...
    def estimate_radius(self, arg0: Atom) -> float:
        ...
    def initialize_grid(self) -> None:
        ...
    def mott_bethe_factor(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> float:
        ...
    def put_model_density_on_grid(self, arg0: Model) -> None:
        ...
    def reciprocal_space_multiplier(self, arg0: float) -> float:
        ...
    def set_grid_cell_and_spacegroup(self, arg0: Structure) -> None:
        ...
    def set_refmac_compatible_blur(self, arg0: Model) -> None:
        ...
    @property
    def grid(self) -> FloatGrid:
        ...
class DensityCalculatorX:
    addends: Addends
    blur: float
    cutoff: float
    d_min: float
    rate: float
    def __init__(self) -> None:
        ...
    def add_atom_density_to_grid(self, arg0: Atom) -> None:
        ...
    def add_c_contribution_to_grid(self, arg0: Atom, arg1: float) -> None:
        ...
    def add_model_density_to_grid(self, arg0: Model) -> None:
        ...
    def estimate_radius(self, arg0: Atom) -> float:
        ...
    def initialize_grid(self) -> None:
        ...
    def mott_bethe_factor(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> float:
        ...
    def put_model_density_on_grid(self, arg0: Model) -> None:
        ...
    def reciprocal_space_multiplier(self, arg0: float) -> float:
        ...
    def set_grid_cell_and_spacegroup(self, arg0: Structure) -> None:
        ...
    def set_refmac_compatible_blur(self, arg0: Model) -> None:
        ...
    @property
    def grid(self) -> FloatGrid:
        ...
class DiffractionInfo:
    beamline: str
    collection_date: str
    detector: str
    detector_make: str
    id: str
    mono_or_laue: str
    monochromator: str
    optics: str
    scattering_type: str
    source: str
    source_type: str
    synchrotron: str
    temperature: float
    wavelengths: str
    def __init__(self) -> None:
        ...
class Element:
    def __eq__(self, arg0: Element) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self, arg0: str) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    def __repr__(self) -> str:
        ...
    @property
    def atomic_number(self) -> int:
        ...
    @property
    def c4322(self) -> C4322Coef:
        ...
    @property
    def covalent_r(self) -> float:
        ...
    @property
    def is_hydrogen(self) -> bool:
        ...
    @property
    def is_metal(self) -> bool:
        ...
    @property
    def it92(self) -> IT92Coef:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def neutron92(self) -> Neutron92:
        ...
    @property
    def vdw_r(self) -> float:
        ...
    @property
    def weight(self) -> float:
        ...
class EnerLib:
    pass
class Entity:
    entity_type: EntityType
    full_sequence: list[str]
    name: str
    polymer_type: PolymerType
    sifts_unp_acc: list[str]
    subchains: list[str]
    @staticmethod
    def first_mon(arg0: str) -> str:
        ...
    def __init__(self, arg0: str) -> None:
        ...
    def __repr__(self) -> str:
        ...
class EntityList:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> EntityList:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Entity:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: EntityList) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        """
        Return the canonical string representation of this list.
        """
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Entity) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: EntityList) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Entity) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: EntityList) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Entity) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Entity:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Entity:
        """
        Remove and return the item at index ``i``
        """
class EntityType:
    """
    Members:
    
      Unknown
    
      Polymer
    
      NonPolymer
    
      Branched
    
      Water
    """
    Branched: typing.ClassVar[EntityType]  # value = <EntityType.Branched: 3>
    NonPolymer: typing.ClassVar[EntityType]  # value = <EntityType.NonPolymer: 2>
    Polymer: typing.ClassVar[EntityType]  # value = <EntityType.Polymer: 1>
    Unknown: typing.ClassVar[EntityType]  # value = <EntityType.Unknown: 0>
    Water: typing.ClassVar[EntityType]  # value = <EntityType.Water: 4>
    __members__: typing.ClassVar[dict[str, EntityType]]  # value = {'Unknown': <EntityType.Unknown: 0>, 'Polymer': <EntityType.Polymer: 1>, 'NonPolymer': <EntityType.NonPolymer: 2>, 'Branched': <EntityType.Branched: 3>, 'Water': <EntityType.Water: 4>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ExperimentInfo:
    b_wilson: float
    diffraction_ids: list[str]
    method: str
    number_of_crystals: int
    reflections: ReflectionsInfo
    shells: list[ReflectionsInfo]
    unique_reflections: int
    def __init__(self) -> None:
        ...
class FTransform(Transform):
    def apply(self, arg0: Fractional) -> Fractional:
        ...
class FastaSeq:
    @property
    def header(self) -> str:
        ...
    @property
    def seq(self) -> str:
        ...
class FirstConformerAtoms:
    def __iter__(self) -> typing.Iterator:
        ...
class FirstConformerRes:
    def __iter__(self) -> typing.Iterator:
        ...
class FirstConformerResSpan:
    def __iter__(self) -> typing.Iterator:
        ...
class FloatAsuData:
    spacegroup: SpaceGroup
    unit_cell: UnitCell
    def __getitem__(self, index: int) -> FloatHklValue:
        ...
    def __init__(self, cell: UnitCell, sg: SpaceGroup, miller_array: numpy.ndarray, value_array: numpy.ndarray) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def calculate_correlation(self, arg0: FloatAsuData) -> Correlation:
        ...
    def copy(self) -> FloatAsuData:
        ...
    def count_equal_values(self, arg0: FloatAsuData) -> int:
        ...
    def ensure_asu(self, tnt_asu: bool = False) -> None:
        ...
    def ensure_sorted(self) -> None:
        ...
    def make_1_d2_array(self) -> numpy.ndarray:
        ...
    def make_d_array(self) -> numpy.ndarray:
        ...
    @property
    def miller_array(self) -> numpy.ndarray:
        ...
    @property
    def value_array(self) -> numpy.ndarray:
        ...
class FloatGrid(FloatGridBase):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, nx: int, ny: int, nz: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray, cell: UnitCell = None, spacegroup: SpaceGroup = None) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def add_soft_edge_to_mask(self, arg0: float) -> None:
        ...
    def change_values(self, old_value: float, new_value: float) -> None:
        ...
    def clone(self) -> FloatGrid:
        ...
    def copy_metadata_from(self, arg0: GridMeta) -> None:
        ...
    def get_nearest_point(self, arg0: Position) -> FloatGridBase.Point:
        ...
    def get_point(self, arg0: int, arg1: int, arg2: int) -> FloatGridBase.Point:
        ...
    def get_subarray(self, start: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)], shape: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> numpy.ndarray:
        ...
    def get_value(self, arg0: int, arg1: int, arg2: int) -> float:
        ...
    @typing.overload
    def interpolate_value(self, arg0: Fractional) -> float:
        ...
    @typing.overload
    def interpolate_value(self, arg0: Position) -> float:
        ...
    def interpolate_values(self, arg0: numpy.ndarray, arg1: Transform, order: int = 2) -> None:
        ...
    def mask_points_in_constant_radius(self, model: Model, radius: float, value: float, ignore_hydrogen: bool = False, ignore_zero_occupancy_atoms: bool = False) -> None:
        ...
    def masked_asu(self) -> MaskedFloatGrid:
        ...
    def normalize(self) -> None:
        ...
    def point_to_fractional(self, arg0: FloatGridBase.Point) -> Fractional:
        ...
    def point_to_position(self, arg0: FloatGridBase.Point) -> Position:
        ...
    def resample_to(self, dest: FloatGrid, order: int) -> None:
        ...
    def set_points_around(self, position: Position, radius: float, value: float, use_pbc: bool = True) -> None:
        ...
    def set_size(self, arg0: int, arg1: int, arg2: int) -> None:
        ...
    def set_size_from_spacing(self, spacing: float, rounding: GridSizeRounding) -> None:
        ...
    def set_subarray(self, arr: numpy.ndarray, start: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> None:
        ...
    def set_unit_cell(self, arg0: UnitCell) -> None:
        ...
    def set_value(self, arg0: int, arg1: int, arg2: int, arg3: float) -> None:
        ...
    def setup_from(self, st: Structure, spacing: float) -> None:
        ...
    def symmetrize_abs_max(self) -> None:
        ...
    def symmetrize_avg(self) -> None:
        ...
    def symmetrize_max(self) -> None:
        ...
    def symmetrize_min(self) -> None:
        ...
    def symmetrize_sum(self) -> None:
        ...
    @typing.overload
    def tricubic_interpolation(self, arg0: Fractional) -> float:
        ...
    @typing.overload
    def tricubic_interpolation(self, arg0: Position) -> float:
        ...
    def tricubic_interpolation_der(self, arg0: Fractional) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(4)]:
        ...
    @property
    def spacing(self) -> tuple:
        ...
class FloatGridBase(GridMeta):
    class Point:
        value: float
        def __repr__(self) -> str:
            ...
        @property
        def u(self) -> int:
            ...
        @property
        def v(self) -> int:
            ...
        @property
        def w(self) -> int:
            ...
    def __iter__(self) -> typing.Iterator:
        ...
    def calculate_correlation(self, arg0: FloatGridBase) -> Correlation:
        ...
    def fill(self, value: float) -> None:
        ...
    def get_nonzero_extent(self) -> FractionalBox:
        ...
    def index_to_point(self, arg0: int) -> FloatGridBase.Point:
        ...
    def point_to_index(self, arg0: FloatGridBase.Point) -> int:
        ...
    def sum(self) -> float:
        ...
    @property
    def array(self) -> numpy.ndarray:
        ...
class FloatHklValue:
    value: float
    def __repr__(self) -> str:
        ...
    @property
    def hkl(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
class Fractional(Vec3):
    def __add__(self, arg0: Fractional) -> Fractional:
        ...
    def __getitem__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __sub__(self, arg0: Fractional) -> Fractional:
        ...
    def wrap_to_unit(self) -> Fractional:
        ...
    def wrap_to_zero(self) -> Fractional:
        ...
class FractionalBox:
    maximum: Fractional
    minimum: Fractional
    def __init__(self) -> None:
        ...
    def add_margin(self, arg0: float) -> None:
        ...
    def extend(self, arg0: Fractional) -> None:
        ...
    def get_size(self) -> Fractional:
        ...
class GridMeta:
    spacegroup: SpaceGroup
    unit_cell: UnitCell
    def get_fractional(self, arg0: int, arg1: int, arg2: int) -> Fractional:
        ...
    def get_position(self, arg0: int, arg1: int, arg2: int) -> Position:
        ...
    @property
    def axis_order(self) -> AxisOrder:
        ...
    @property
    def nu(self) -> int:
        """
        size in the first (fastest-changing) dim
        """
    @property
    def nv(self) -> int:
        """
        size in the second dimension
        """
    @property
    def nw(self) -> int:
        """
        size in the third (slowest-changing) dim
        """
    @property
    def point_count(self) -> int:
        ...
    @property
    def shape(self) -> tuple:
        ...
class GridSizeRounding:
    """
    Members:
    
      Nearest
    
      Up
    
      Down
    """
    Down: typing.ClassVar[GridSizeRounding]  # value = <GridSizeRounding.Down: 2>
    Nearest: typing.ClassVar[GridSizeRounding]  # value = <GridSizeRounding.Nearest: 0>
    Up: typing.ClassVar[GridSizeRounding]  # value = <GridSizeRounding.Up: 1>
    __members__: typing.ClassVar[dict[str, GridSizeRounding]]  # value = {'Nearest': <GridSizeRounding.Nearest: 0>, 'Up': <GridSizeRounding.Up: 1>, 'Down': <GridSizeRounding.Down: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class GroupOps:
    __hash__: typing.ClassVar[None] = None
    def __deepcopy__(self, memo: dict) -> GroupOps:
        ...
    def __eq__(self, arg0: GroupOps) -> bool:
        ...
    def __init__(self, arg0: list[Op]) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def add_inversion(self) -> bool:
        ...
    def add_missing_elements(self) -> None:
        ...
    def centric_flag_array(self, arg0: numpy.ndarray) -> numpy.ndarray:
        ...
    def change_basis_backward(self, cob: Op) -> None:
        """
        Applies inverse of the change-of-basis operator (in place).
        """
    def change_basis_forward(self, cob: Op) -> None:
        """
        Applies the change-of-basis operator (in place).
        """
    def derive_symmorphic(self) -> GroupOps:
        ...
    def epsilon_factor(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> int:
        ...
    def epsilon_factor_array(self, arg0: numpy.ndarray) -> numpy.ndarray:
        ...
    def epsilon_factor_without_centering(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> int:
        ...
    def epsilon_factor_without_centering_array(self, arg0: numpy.ndarray) -> numpy.ndarray:
        ...
    def find_centering(self) -> str:
        ...
    def find_grid_factors(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        """
        Minimal multiplicity for real-space grid (e.g. 1,1,6 for P61).
        """
    def has_same_centring(self, arg0: GroupOps) -> bool:
        ...
    def has_same_rotations(self, arg0: GroupOps) -> bool:
        ...
    def is_centrosymmetric(self) -> bool:
        ...
    def is_reflection_centric(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> bool:
        ...
    def is_systematically_absent(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> bool:
        ...
    def systematic_absences(self, arg0: numpy.ndarray) -> numpy.ndarray:
        ...
    @property
    def cen_ops(self) -> list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]]:
        """
        Centering vectors.
        """
    @cen_ops.setter
    def cen_ops(self, arg0: list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]]) -> None:
        ...
    @property
    def sym_ops(self) -> list[Op]:
        """
        Symmetry operations (to be combined with centering vectors).
        """
    @sym_ops.setter
    def sym_ops(self, arg0: list[Op]) -> None:
        ...
class GruberVector:
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]) -> None:
        ...
    @typing.overload
    def __init__(self, cell: UnitCell, sg: SpaceGroup, track_change_of_basis: bool = False) -> None:
        ...
    @typing.overload
    def __init__(self, cell: UnitCell, centring: str, track_change_of_basis: bool = False) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def buerger_reduce(self) -> int:
        ...
    def cell_parameters(self) -> tuple:
        ...
    def get_cell(self) -> UnitCell:
        ...
    def is_buerger(self, epsilon: float = 1e-09) -> bool:
        ...
    def is_niggli(self, epsilon: float = 1e-09) -> bool:
        ...
    def is_normalized(self) -> bool:
        ...
    def niggli_reduce(self, epsilon: float = 1e-09, iteration_limit: int = 100) -> int:
        ...
    def niggli_step(self, epsilon: float) -> bool:
        ...
    def normalize(self, epsilon: float = 1e-09) -> None:
        ...
    def selling(self) -> SellingVector:
        ...
    @property
    def change_of_basis(self) -> Op:
        ...
    @property
    def parameters(self) -> tuple:
        ...
class Helix:
    class HelixClass:
        """
        Members:
        
          UnknownHelix
        
          RAlpha
        
          ROmega
        
          RPi
        
          RGamma
        
          R310
        
          LAlpha
        
          LOmega
        
          LGamma
        
          Helix27
        
          HelixPolyProlineNone
        """
        Helix27: typing.ClassVar[Helix.HelixClass]  # value = <HelixClass.Helix27: 9>
        HelixPolyProlineNone: typing.ClassVar[Helix.HelixClass]  # value = <HelixClass.HelixPolyProlineNone: 10>
        LAlpha: typing.ClassVar[Helix.HelixClass]  # value = <HelixClass.LAlpha: 6>
        LGamma: typing.ClassVar[Helix.HelixClass]  # value = <HelixClass.LGamma: 8>
        LOmega: typing.ClassVar[Helix.HelixClass]  # value = <HelixClass.LOmega: 7>
        R310: typing.ClassVar[Helix.HelixClass]  # value = <HelixClass.R310: 5>
        RAlpha: typing.ClassVar[Helix.HelixClass]  # value = <HelixClass.RAlpha: 1>
        RGamma: typing.ClassVar[Helix.HelixClass]  # value = <HelixClass.RGamma: 4>
        ROmega: typing.ClassVar[Helix.HelixClass]  # value = <HelixClass.ROmega: 2>
        RPi: typing.ClassVar[Helix.HelixClass]  # value = <HelixClass.RPi: 3>
        UnknownHelix: typing.ClassVar[Helix.HelixClass]  # value = <HelixClass.UnknownHelix: 0>
        __members__: typing.ClassVar[dict[str, Helix.HelixClass]]  # value = {'UnknownHelix': <HelixClass.UnknownHelix: 0>, 'RAlpha': <HelixClass.RAlpha: 1>, 'ROmega': <HelixClass.ROmega: 2>, 'RPi': <HelixClass.RPi: 3>, 'RGamma': <HelixClass.RGamma: 4>, 'R310': <HelixClass.R310: 5>, 'LAlpha': <HelixClass.LAlpha: 6>, 'LOmega': <HelixClass.LOmega: 7>, 'LGamma': <HelixClass.LGamma: 8>, 'Helix27': <HelixClass.Helix27: 9>, 'HelixPolyProlineNone': <HelixClass.HelixPolyProlineNone: 10>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    end: AtomAddress
    length: int
    pdb_helix_class: Helix.HelixClass
    start: AtomAddress
    def __init__(self) -> None:
        ...
class HelixList:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> HelixList:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Helix:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: HelixList) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Helix) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: HelixList) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Helix) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: HelixList) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Helix) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Helix:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Helix:
        """
        Remove and return the item at index ``i``
        """
class HklMatch:
    def __init__(self, hkl: numpy.ndarray, ref: numpy.ndarray) -> None:
        ...
    def aligned(self, arg0: numpy.ndarray) -> numpy.ndarray:
        ...
    @property
    def pos(self) -> list[int]:
        ...
class HowToNameCopiedChain:
    """
    Members:
    
      Short
    
      AddNumber
    
      Dup
    """
    AddNumber: typing.ClassVar[HowToNameCopiedChain]  # value = <HowToNameCopiedChain.AddNumber: 1>
    Dup: typing.ClassVar[HowToNameCopiedChain]  # value = <HowToNameCopiedChain.Dup: 2>
    Short: typing.ClassVar[HowToNameCopiedChain]  # value = <HowToNameCopiedChain.Short: 0>
    __members__: typing.ClassVar[dict[str, HowToNameCopiedChain]]  # value = {'Short': <HowToNameCopiedChain.Short: 0>, 'AddNumber': <HowToNameCopiedChain.AddNumber: 1>, 'Dup': <HowToNameCopiedChain.Dup: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class HydrogenChange:
    """
    Members:
    
      NoChange
    
      Shift
    
      Remove
    
      ReAdd
    
      ReAddButWater
    
      ReAddKnown
    """
    NoChange: typing.ClassVar[HydrogenChange]  # value = <HydrogenChange.NoChange: 0>
    ReAdd: typing.ClassVar[HydrogenChange]  # value = <HydrogenChange.ReAdd: 3>
    ReAddButWater: typing.ClassVar[HydrogenChange]  # value = <HydrogenChange.ReAddButWater: 4>
    ReAddKnown: typing.ClassVar[HydrogenChange]  # value = <HydrogenChange.ReAddKnown: 5>
    Remove: typing.ClassVar[HydrogenChange]  # value = <HydrogenChange.Remove: 2>
    Shift: typing.ClassVar[HydrogenChange]  # value = <HydrogenChange.Shift: 1>
    __members__: typing.ClassVar[dict[str, HydrogenChange]]  # value = {'NoChange': <HydrogenChange.NoChange: 0>, 'Shift': <HydrogenChange.Shift: 1>, 'Remove': <HydrogenChange.Remove: 2>, 'ReAdd': <HydrogenChange.ReAdd: 3>, 'ReAddButWater': <HydrogenChange.ReAddButWater: 4>, 'ReAddKnown': <HydrogenChange.ReAddKnown: 5>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class IT92Coef:
    def calculate_density_iso(self, r2: numpy.ndarray, B: float) -> typing.Any:
        ...
    def calculate_sf(self, stol2: numpy.ndarray) -> typing.Any:
        ...
    def get_coefs(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(9)]:
        ...
    def set_coefs(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(9)]) -> None:
        ...
    @property
    def a(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(4)]:
        ...
    @property
    def b(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(4)]:
        ...
    @property
    def c(self) -> float:
        ...
class InfoMap:
    def __bool__(self) -> bool:
        """
        Check whether the map is nonempty
        """
    @typing.overload
    def __contains__(self, arg0: str) -> bool:
        ...
    @typing.overload
    def __contains__(self, arg0: typing.Any) -> bool:
        ...
    def __delitem__(self, arg0: str) -> None:
        ...
    def __getitem__(self, arg0: str) -> str:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        """
        Return the canonical string representation of this map.
        """
    def __setitem__(self, arg0: str, arg1: str) -> None:
        ...
    def items(self) -> typing.ItemsView[str, str]:
        ...
    def keys(self) -> typing.KeysView[str]:
        ...
    def values(self) -> typing.ValuesView[str]:
        ...
class Int8Grid(Int8GridBase):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, nx: int, ny: int, nz: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray, cell: UnitCell = None, spacegroup: SpaceGroup = None) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def change_values(self, old_value: int, new_value: int) -> None:
        ...
    def clone(self) -> Int8Grid:
        ...
    def copy_metadata_from(self, arg0: GridMeta) -> None:
        ...
    def get_nearest_point(self, arg0: Position) -> Int8GridBase.Point:
        ...
    def get_point(self, arg0: int, arg1: int, arg2: int) -> Int8GridBase.Point:
        ...
    def get_subarray(self, start: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)], shape: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> numpy.ndarray:
        ...
    def get_value(self, arg0: int, arg1: int, arg2: int) -> int:
        ...
    def mask_points_in_constant_radius(self, model: Model, radius: float, value: int, ignore_hydrogen: bool = False, ignore_zero_occupancy_atoms: bool = False) -> None:
        ...
    def masked_asu(self) -> MaskedInt8Grid:
        ...
    def point_to_fractional(self, arg0: Int8GridBase.Point) -> Fractional:
        ...
    def point_to_position(self, arg0: Int8GridBase.Point) -> Position:
        ...
    def resample_to(self, dest: Int8Grid, order: int) -> None:
        ...
    def set_points_around(self, position: Position, radius: float, value: int, use_pbc: bool = True) -> None:
        ...
    def set_size(self, arg0: int, arg1: int, arg2: int) -> None:
        ...
    def set_size_from_spacing(self, spacing: float, rounding: GridSizeRounding) -> None:
        ...
    def set_subarray(self, arr: numpy.ndarray, start: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> None:
        ...
    def set_unit_cell(self, arg0: UnitCell) -> None:
        ...
    def set_value(self, arg0: int, arg1: int, arg2: int, arg3: int) -> None:
        ...
    def setup_from(self, st: Structure, spacing: float) -> None:
        ...
    def symmetrize_abs_max(self) -> None:
        ...
    def symmetrize_max(self) -> None:
        ...
    def symmetrize_min(self) -> None:
        ...
    def symmetrize_sum(self) -> None:
        ...
    @property
    def spacing(self) -> tuple:
        ...
class Int8GridBase(GridMeta):
    class Point:
        value: int
        def __repr__(self) -> str:
            ...
        @property
        def u(self) -> int:
            ...
        @property
        def v(self) -> int:
            ...
        @property
        def w(self) -> int:
            ...
    def __iter__(self) -> typing.Iterator:
        ...
    def fill(self, value: int) -> None:
        ...
    def get_nonzero_extent(self) -> FractionalBox:
        ...
    def index_to_point(self, arg0: int) -> Int8GridBase.Point:
        ...
    def point_to_index(self, arg0: Int8GridBase.Point) -> int:
        ...
    def sum(self) -> int:
        ...
    @property
    def array(self) -> numpy.ndarray:
        ...
class IntAsuData:
    spacegroup: SpaceGroup
    unit_cell: UnitCell
    def __getitem__(self, index: int) -> IntHklValue:
        ...
    def __init__(self, cell: UnitCell, sg: SpaceGroup, miller_array: numpy.ndarray, value_array: numpy.ndarray) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def copy(self) -> IntAsuData:
        ...
    def count_equal_values(self, arg0: IntAsuData) -> int:
        ...
    def ensure_asu(self, tnt_asu: bool = False) -> None:
        ...
    def ensure_sorted(self) -> None:
        ...
    def make_1_d2_array(self) -> numpy.ndarray:
        ...
    def make_d_array(self) -> numpy.ndarray:
        ...
    @property
    def miller_array(self) -> numpy.ndarray:
        ...
    @property
    def value_array(self) -> numpy.ndarray:
        ...
class IntHklValue:
    value: int
    def __repr__(self) -> str:
        ...
    @property
    def hkl(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
class Intensities:
    spacegroup: SpaceGroup
    type: DataType
    unit_cell: UnitCell
    def __init__(self) -> None:
        ...
    def merge_in_place(self, itype: DataType) -> None:
        ...
    def prepare_merged_mtz(self, with_nobs: bool) -> Mtz:
        ...
    def read_mtz(self, mtz: Mtz, type: DataType) -> None:
        ...
    def remove_systematic_absences(self) -> None:
        ...
    def resolution_range(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]:
        ...
    def set_data(self, cell: UnitCell, sg: SpaceGroup, miller_array: numpy.ndarray, value_array: numpy.ndarray, sigma_array: numpy.ndarray) -> None:
        ...
    @property
    def isign_array(self) -> numpy.ndarray:
        ...
    @property
    def miller_array(self) -> numpy.ndarray:
        ...
    @property
    def nobs_array(self) -> numpy.ndarray:
        ...
    @property
    def sigma_array(self) -> numpy.ndarray:
        ...
    @property
    def value_array(self) -> numpy.ndarray:
        ...
class LinkHunt:
    class Match:
        @property
        def bond_length(self) -> float:
            ...
        @property
        def chem_link(self) -> ChemLink:
            ...
        @property
        def chem_link_count(self) -> int:
            ...
        @property
        def conn(self) -> Connection:
            ...
        @property
        def cra1(self) -> CRA:
            ...
        @property
        def cra2(self) -> CRA:
            ...
        @property
        def same_image(self) -> bool:
            ...
    def __init__(self) -> None:
        ...
    def find_possible_links(self, st: Structure, bond_margin: float, radius_margin: float, ignore: ContactSearch.Ignore = ContactSearch.Ignore.SameResidue) -> list[LinkHunt.Match]:
        ...
    def index_chem_links(self, monlib: MonLib, use_alias: bool = True) -> None:
        ...
class MapSetup:
    """
    Members:
    
      Full
    
      NoSymmetry
    
      ReorderOnly
    """
    Full: typing.ClassVar[MapSetup]  # value = <MapSetup.Full: 0>
    NoSymmetry: typing.ClassVar[MapSetup]  # value = <MapSetup.NoSymmetry: 1>
    ReorderOnly: typing.ClassVar[MapSetup]  # value = <MapSetup.ReorderOnly: 2>
    __members__: typing.ClassVar[dict[str, MapSetup]]  # value = {'Full': <MapSetup.Full: 0>, 'NoSymmetry': <MapSetup.NoSymmetry: 1>, 'ReorderOnly': <MapSetup.ReorderOnly: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class MaskedFloatGrid:
    def __iter__(self) -> typing.Iterator:
        ...
    @property
    def grid(self) -> FloatGrid:
        ...
    @property
    def mask_array(self) -> numpy.ndarray:
        ...
class MaskedInt8Grid:
    def __iter__(self) -> typing.Iterator:
        ...
    @property
    def grid(self) -> Int8Grid:
        ...
    @property
    def mask_array(self) -> numpy.ndarray:
        ...
class Mat33:
    @staticmethod
    def __matmul__(*args, **kwargs):
        """
        multiply(*args, **kwargs)
        Overloaded function.
        
        1. multiply(self: gemmi.Mat33, arg0: gemmi.Mat33) -> gemmi.Mat33
        
        2. multiply(self: gemmi.Mat33, arg0: gemmi.Vec3) -> gemmi.Vec3
        """
    def __add__(self, arg0: Mat33) -> Mat33:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]], pybind11_stubgen.typing_ext.FixedSize(3)]) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __sub__(self, arg0: Mat33) -> Mat33:
        ...
    def approx(self, other: Mat33, epsilon: float) -> bool:
        ...
    def column_copy(self, arg0: int) -> Vec3:
        ...
    def determinant(self) -> float:
        ...
    def fromlist(self, arg0: typing.Annotated[list[typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]], pybind11_stubgen.typing_ext.FixedSize(3)]) -> None:
        ...
    def inverse(self) -> Mat33:
        ...
    def is_identity(self) -> bool:
        ...
    def left_multiply(self, arg0: Vec3) -> Vec3:
        ...
    @typing.overload
    def multiply(self, arg0: Mat33) -> Mat33:
        ...
    @typing.overload
    def multiply(self, arg0: Vec3) -> Vec3:
        ...
    def multiply_by_diagonal(self, arg0: Vec3) -> Mat33:
        ...
    def row_copy(self, arg0: int) -> Vec3:
        ...
    def tolist(self) -> typing.Annotated[list[typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def trace(self) -> float:
        ...
    def transpose(self) -> Mat33:
        ...
class Metadata:
    authors: list[str]
    refinement: list[RefinementInfo]
    software: list[SoftwareItem]
class MmcifOutputGroups:
    assembly: bool
    atom_type: bool
    atoms: bool
    auth_all: bool
    author: bool
    block_name: bool
    cell: bool
    chem_comp: bool
    cis: bool
    conn: bool
    database_status: bool
    diffrn: bool
    entity: bool
    entity_poly: bool
    entity_poly_seq: bool
    entry: bool
    exptl: bool
    group_pdb: bool
    ncs: bool
    origx: bool
    refine: bool
    reflns: bool
    scale: bool
    software: bool
    struct_asym: bool
    struct_biol: bool
    struct_conf: bool
    struct_ref: bool
    struct_sheet: bool
    symmetry: bool
    title_keywords: bool
    tls: bool
    def __init__(self, all: bool, **kwargs) -> None:
        ...
class ModRes:
    chain_name: str
    details: str
    mod_id: str
    parent_comp_id: str
    res_id: ResidueId
    def __init__(self) -> None:
        ...
class Model:
    name: str
    @typing.overload
    def __delitem__(self, name: str) -> None:
        ...
    @typing.overload
    def __delitem__(self, index: int) -> None:
        ...
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        ...
    @typing.overload
    def __getitem__(self, index: int) -> Chain:
        ...
    @typing.overload
    def __getitem__(self, name: str) -> Chain:
        ...
    def __init__(self, arg0: str) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def add_chain(self, chain: Chain, pos: int = -1, unique_name: bool = False) -> Chain:
        ...
    @typing.overload
    def add_chain(self, name: str) -> Chain:
        ...
    def all(self) -> CraGenerator:
        ...
    def calculate_center_of_mass(self) -> Position:
        ...
    def calculate_mass(self) -> float:
        ...
    def clone(self) -> Model:
        ...
    def count_atom_sites(self, sel: Selection = None) -> int:
        ...
    def count_hydrogen_sites(self) -> int:
        ...
    def count_occupancies(self, sel: Selection = None) -> float:
        ...
    def find_chain(self, name: str) -> Chain:
        ...
    def find_cra(self, arg0: AtomAddress, ignore_segment: bool = False) -> CRA:
        ...
    def find_last_chain(self, name: str) -> Chain:
        ...
    def find_residue_group(self, chain: str, seqid: SeqId) -> ResidueGroup:
        ...
    def get_all_residue_names(self) -> list[str]:
        ...
    def get_cra(self, arg0: Atom) -> CRA:
        ...
    def get_parent_of(self, arg0: Residue) -> Chain:
        ...
    def get_subchain(self, name: str) -> ResidueSpan:
        ...
    def has_hydrogen(self) -> bool:
        ...
    def remove_alternative_conformations(self) -> None:
        ...
    def remove_chain(self, name: str) -> None:
        ...
    def remove_hydrogens(self) -> None:
        ...
    def remove_ligands_and_waters(self) -> None:
        ...
    def remove_waters(self) -> None:
        ...
    def sole_residue(self, chain: str, seqid: SeqId) -> Residue:
        ...
    def split_chains_by_segments(self, arg0: HowToNameCopiedChain) -> None:
        ...
    def subchains(self) -> list[ResidueSpan]:
        ...
    def transform_pos_and_adp(self, tr: Transform) -> None:
        ...
class MonLib:
    monomer_dir: str
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def add_monomer_if_present(self, arg0: cif.Block) -> None:
        ...
    def find_ideal_distance(self, arg0: CRA, arg1: CRA) -> float:
        ...
    def get_link(self, link_id: str) -> ChemLink:
        ...
    def get_mod(self, name: str) -> ChemMod:
        ...
    def match_link(self, res1: Residue, atom1: str, alt1: str, res2: Residue, atom2: str, alt2: str, min_bond_sq: float = 0.0) -> tuple[ChemLink, bool, ChemComp.Aliasing, ChemComp.Aliasing]:
        ...
    def path(self, code: str = '') -> str:
        ...
    def read_monomer_cif(self, arg0: str) -> None:
        ...
    def read_monomer_doc(self, arg0: cif.Document) -> None:
        ...
    def read_monomer_lib(self, arg0: str, arg1: list[str]) -> bool:
        ...
    def test_link(self, link: ChemLink, res1: str, atom1: str, res2: str, atom2: str) -> tuple:
        ...
    def update_old_atom_names(self, arg0: Structure) -> str:
        ...
    @property
    def ener_lib(self) -> EnerLib:
        ...
    @property
    def links(self) -> ChemLinkMap:
        ...
    @property
    def modifications(self) -> ChemModMap:
        ...
    @property
    def monomers(self) -> ChemCompMap:
        ...
class Mtz:
    class Batch:
        axes: list[str]
        cell: UnitCell
        dataset_id: int
        floats: BatchFloats
        ints: BatchInts
        number: int
        title: str
        wavelength: float
        def __init__(self) -> None:
            ...
        def clone(self) -> Mtz.Batch:
            ...
    class Column:
        dataset_id: int
        idx: int
        label: str
        max_value: float
        min_value: float
        source: str
        type: str
        def __getitem__(self, index: int) -> float:
            ...
        def __iter__(self) -> typing.Iterator:
            ...
        def __len__(self) -> int:
            ...
        def __repr__(self) -> str:
            ...
        def is_integer(self) -> bool:
            ...
        @property
        def array(self) -> numpy.ndarray:
            ...
        @property
        def dataset(self) -> Mtz.Dataset:
            ...
    class Dataset:
        cell: UnitCell
        crystal_name: str
        dataset_name: str
        id: int
        project_name: str
        wavelength: float
        def __repr__(self) -> str:
            ...
    appended_text: str
    batches: MtzBatches
    cell: UnitCell
    columns: MtzColumns
    datasets: MtzDatasets
    history: list[str]
    max_1_d2: float
    min_1_d2: float
    nreflections: int
    sort_order: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(5)]
    spacegroup: SpaceGroup
    title: str
    valm: float
    def __init__(self, with_base: bool = False) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def add_column(self, label: str, type: str, dataset_id: int = -1, pos: int = -1, expand_data: bool = True) -> Mtz.Column:
        ...
    def add_dataset(self, name: str) -> Mtz.Dataset:
        ...
    def column_labels(self) -> list[str]:
        ...
    def column_with_label(self, label: str, dataset: Mtz.Dataset = None) -> Mtz.Column:
        ...
    def columns_with_type(self, type: str) -> list[Mtz.Column]:
        ...
    def copy_column(self, dest_idx: int, src_col: Mtz.Column, trailing_cols: list[str] = []) -> Mtz.Column:
        ...
    def count(self, label: str) -> int:
        ...
    def data_fits_into(self, size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> bool:
        ...
    def dataset(self, id: int) -> Mtz.Dataset:
        ...
    def ensure_asu(self, tnt_asu: bool = False) -> None:
        ...
    def expand_to_p1(self) -> None:
        ...
    def get_cell(self, dataset: int = -1) -> UnitCell:
        ...
    def get_f_phi(self, f: str, phi: str, as_is: bool = False) -> ComplexAsuData:
        ...
    def get_f_phi_on_grid(self, f: str, phi: str, size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)], half_l: bool = False, order: AxisOrder = AxisOrder.XYZ) -> ReciprocalComplexGrid:
        ...
    def get_float(self, col: str, as_is: bool = False) -> FloatAsuData:
        ...
    def get_int(self, col: str, as_is: bool = False) -> IntAsuData:
        ...
    def get_size_for_hkl(self, min_size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] = [0, 0, 0], sample_rate: float = 0.0) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def get_value_on_grid(self, label: str, size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)], half_l: bool = False, order: AxisOrder = AxisOrder.XYZ) -> ReciprocalFloatGrid:
        ...
    def get_value_sigma(self, f: str, sigma: str, as_is: bool = False) -> ValueSigmaAsuData:
        ...
    def make_1_d2_array(self, dataset: int = -1) -> numpy.ndarray:
        ...
    def make_d_array(self, dataset: int = -1) -> numpy.ndarray:
        ...
    def make_miller_array(self) -> numpy.ndarray:
        ...
    def reindex(self, op: Op) -> str:
        ...
    def remove_column(self, index: int) -> None:
        ...
    def replace_column(self, dest_idx: int, src_col: Mtz.Column, trailing_cols: list[str] = []) -> Mtz.Column:
        ...
    def resolution_high(self) -> float:
        ...
    def resolution_low(self) -> float:
        ...
    def rfree_column(self) -> Mtz.Column:
        ...
    def row_as_dict(self, hkl: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> dict:
        ...
    def set_cell_for_all(self, arg0: UnitCell) -> None:
        ...
    @typing.overload
    def set_data(self, asu_data: ComplexAsuData) -> None:
        ...
    @typing.overload
    def set_data(self, asu_data: FloatAsuData) -> None:
        ...
    @typing.overload
    def set_data(self, array: numpy.ndarray) -> None:
        ...
    def sort(self, use_first: int = 3) -> bool:
        ...
    def switch_to_asu_hkl(self) -> bool:
        ...
    def switch_to_original_hkl(self) -> bool:
        ...
    def transform_f_phi_to_map(self, f: str, phi: str, min_size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] = [0, 0, 0], exact_size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] = [0, 0, 0], sample_rate: float = 0.0, order: AxisOrder = AxisOrder.XYZ) -> FloatGrid:
        ...
    def update_reso(self) -> None:
        ...
    def write_to_file(self, path: str) -> None:
        ...
    @property
    def array(self) -> numpy.ndarray:
        ...
    @property
    def nsymop(self) -> int:
        ...
    @property
    def spacegroup_name(self) -> str:
        ...
    @property
    def spacegroup_number(self) -> int:
        ...
class MtzBatches:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> MtzBatches:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Mtz.Batch:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: MtzBatches) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Mtz.Batch) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: MtzBatches) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Mtz.Batch) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: MtzBatches) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Mtz.Batch) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Mtz.Batch:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Mtz.Batch:
        """
        Remove and return the item at index ``i``
        """
class MtzColumns:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> MtzColumns:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Mtz.Column:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: MtzColumns) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Mtz.Column) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: MtzColumns) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Mtz.Column) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: MtzColumns) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Mtz.Column) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Mtz.Column:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Mtz.Column:
        """
        Remove and return the item at index ``i``
        """
class MtzDatasets:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> MtzDatasets:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Mtz.Dataset:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: MtzDatasets) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        """
        Return the canonical string representation of this list.
        """
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Mtz.Dataset) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: MtzDatasets) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Mtz.Dataset) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: MtzDatasets) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Mtz.Dataset) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Mtz.Dataset:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Mtz.Dataset:
        """
        Remove and return the item at index ``i``
        """
class MtzToCif:
    free_flag_value: int
    skip_empty: bool
    skip_negative_sigi: bool
    spec_lines: list[str]
    wavelength: float
    with_comments: bool
    with_history: bool
    def __init__(self) -> None:
        ...
    def write_cif_to_string(self, mtz: Mtz, mtz2: Mtz = None) -> str:
        ...
class NcsOp:
    given: bool
    id: str
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, tr: Transform, id: str = '', given: bool = False) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def apply(self, arg0: Position) -> Position:
        ...
    @property
    def tr(self) -> Transform:
        ...
class NcsOpList:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> NcsOpList:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> NcsOp:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: NcsOpList) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: NcsOp) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: NcsOpList) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: NcsOp) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: NcsOpList) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: NcsOp) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> NcsOp:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> NcsOp:
        """
        Remove and return the item at index ``i``
        """
class NearestImage:
    def __repr__(self) -> str:
        ...
    def dist(self) -> float:
        ...
    def same_asu(self) -> bool:
        ...
    def symmetry_code(self, underscore: bool = True) -> str:
        ...
    @property
    def pbc_shift(self) -> tuple:
        ...
    @property
    def sym_idx(self) -> int:
        ...
class NeighborSearch:
    class Mark:
        def __repr__(self) -> str:
            ...
        def to_cra(self, arg0: Model) -> CRA:
            ...
        def to_site(self, arg0: SmallStructure) -> SmallStructure.Site:
            ...
        @property
        def altloc(self) -> str:
            ...
        @property
        def atom_idx(self) -> int:
            ...
        @property
        def chain_idx(self) -> int:
            ...
        @property
        def element(self) -> Element:
            ...
        @property
        def image_idx(self) -> int:
            ...
        @property
        def pos(self) -> Position:
            ...
        @property
        def residue_idx(self) -> int:
            ...
    @typing.overload
    def __init__(self, model: Model, cell: UnitCell, max_radius: float) -> None:
        ...
    @typing.overload
    def __init__(self, st: Structure, max_radius: float, model_index: int = 0) -> None:
        ...
    @typing.overload
    def __init__(self, small_structure: SmallStructure, max_radius: float) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def add_atom(self, atom: Atom, n_ch: int, n_res: int, n_atom: int) -> None:
        """
        Lower-level alternative to populate()
        """
    def add_chain(self, chain: Chain, include_h: bool = True) -> None:
        ...
    def dist(self, arg0: Position, arg1: Position) -> float:
        ...
    def find_atoms(self, pos: Position, alt: str = '\x00', *, min_dist: float = 0, radius: float = 0) -> VectorMarkPtr:
        ...
    def find_nearest_atom(self, pos: Position, radius: float = ...) -> NeighborSearch.Mark:
        ...
    def find_neighbors(self, atom: Atom, min_dist: float = 0, max_dist: float = 0) -> VectorMarkPtr:
        ...
    def find_site_neighbors(self, atom: SmallStructure.Site, min_dist: float = 0, max_dist: float = 0) -> VectorMarkPtr:
        ...
    def get_image_transformation(self, arg0: int) -> FTransform:
        ...
    def populate(self, include_h: bool = True) -> NeighborSearch:
        """
        Usually run after constructing NeighborSearch.
        """
    @property
    def grid_cell(self) -> UnitCell:
        ...
    @property
    def radius_specified(self) -> float:
        ...
class Neutron92:
    def calculate_density_iso(self, r2: float, B: float) -> float:
        ...
    def calculate_sf(self, stol2: float) -> float:
        ...
    def get_coefs(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(1)]:
        ...
class Op:
    DEN: typing.ClassVar[int] = 24
    def __copy__(self) -> Op:
        ...
    def __deepcopy__(self, memo: dict) -> Op:
        ...
    @typing.overload
    def __eq__(self, arg0: Op) -> bool:
        ...
    @typing.overload
    def __eq__(self, arg0: str) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: str) -> None:
        ...
    @typing.overload
    def __mul__(self, arg0: Op) -> Op:
        ...
    @typing.overload
    def __mul__(self, arg0: str) -> Op:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: str) -> Op:
        ...
    def apply_to_hkl(self, hkl: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def apply_to_xyz(self, xyz: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def combine(self, b: Op) -> Op:
        """
        Combine two symmetry operations.
        """
    def det_rot(self) -> int:
        """
        Determinant of the 3x3 matrix.
        """
    def float_seitz(self) -> typing.Annotated[list[typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(4)]], pybind11_stubgen.typing_ext.FixedSize(4)]:
        """
        Returns Seitz matrix (floats)
        """
    def inverse(self) -> Op:
        """
        Returns inverted operator.
        """
    def phase_shift(self, hkl: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> float:
        ...
    def rot_type(self) -> int:
        ...
    def seitz(self) -> list:
        """
        Returns Seitz matrix (fractions)
        """
    def translated(self, a: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> Op:
        """
        Adds a to tran
        """
    def transposed_rot(self) -> typing.Annotated[list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def triplet(self, style: str = 'x') -> str:
        ...
    def wrap(self) -> Op:
        """
        Wrap the translation part to [0,1)
        """
    @property
    def rot(self) -> typing.Annotated[list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]], pybind11_stubgen.typing_ext.FixedSize(3)]:
        """
        3x3 integer matrix.
        """
    @rot.setter
    def rot(self, arg0: typing.Annotated[list[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]], pybind11_stubgen.typing_ext.FixedSize(3)]) -> None:
        ...
    @property
    def tran(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        """
        Numerators (integers) of the translation vector. Denominator DEN=24.
        """
    @tran.setter
    def tran(self, arg0: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> None:
        ...
class PdbWriteOptions:
    atom_records: bool
    cispep_records: bool
    conect_records: bool
    cryst1_record: bool
    end_record: bool
    link_records: bool
    minimal_file: bool
    numbered_ter: bool
    preserve_serial: bool
    seqres_records: bool
    ssbond_records: bool
    ter_ignores_type: bool
    ter_records: bool
    use_linkr: bool
    def __init__(self, minimal: bool = False, headers_only: bool = False, **kwargs) -> None:
        ...
class PolymerType:
    """
    Members:
    
      PeptideL
    
      PeptideD
    
      Dna
    
      Rna
    
      DnaRnaHybrid
    
      SaccharideD
    
      SaccharideL
    
      Pna
    
      CyclicPseudoPeptide
    
      Other
    
      Unknown
    """
    CyclicPseudoPeptide: typing.ClassVar[PolymerType]  # value = <PolymerType.CyclicPseudoPeptide: 9>
    Dna: typing.ClassVar[PolymerType]  # value = <PolymerType.Dna: 3>
    DnaRnaHybrid: typing.ClassVar[PolymerType]  # value = <PolymerType.DnaRnaHybrid: 5>
    Other: typing.ClassVar[PolymerType]  # value = <PolymerType.Other: 10>
    PeptideD: typing.ClassVar[PolymerType]  # value = <PolymerType.PeptideD: 2>
    PeptideL: typing.ClassVar[PolymerType]  # value = <PolymerType.PeptideL: 1>
    Pna: typing.ClassVar[PolymerType]  # value = <PolymerType.Pna: 8>
    Rna: typing.ClassVar[PolymerType]  # value = <PolymerType.Rna: 4>
    SaccharideD: typing.ClassVar[PolymerType]  # value = <PolymerType.SaccharideD: 6>
    SaccharideL: typing.ClassVar[PolymerType]  # value = <PolymerType.SaccharideL: 7>
    Unknown: typing.ClassVar[PolymerType]  # value = <PolymerType.Unknown: 0>
    __members__: typing.ClassVar[dict[str, PolymerType]]  # value = {'PeptideL': <PolymerType.PeptideL: 1>, 'PeptideD': <PolymerType.PeptideD: 2>, 'Dna': <PolymerType.Dna: 3>, 'Rna': <PolymerType.Rna: 4>, 'DnaRnaHybrid': <PolymerType.DnaRnaHybrid: 5>, 'SaccharideD': <PolymerType.SaccharideD: 6>, 'SaccharideL': <PolymerType.SaccharideL: 7>, 'Pna': <PolymerType.Pna: 8>, 'CyclicPseudoPeptide': <PolymerType.CyclicPseudoPeptide: 9>, 'Other': <PolymerType.Other: 10>, 'Unknown': <PolymerType.Unknown: 0>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class Position(Vec3):
    def __add__(self, arg0: Position) -> Position:
        ...
    def __iadd__(self, arg0: Position) -> Position:
        ...
    def __imul__(self, arg0: float) -> Position:
        ...
    @typing.overload
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Vec3) -> None:
        ...
    def __isub__(self, arg0: Position) -> Position:
        ...
    def __itruediv__(self, arg0: float) -> Position:
        ...
    def __mul__(self, arg0: float) -> Position:
        ...
    def __neg__(self) -> Position:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Position:
        ...
    def __sub__(self, arg0: Position) -> Position:
        ...
    def __truediv__(self, arg0: float) -> Position:
        ...
    def dist(self, arg0: Position) -> float:
        ...
class PositionBox:
    maximum: Position
    minimum: Position
    def __init__(self) -> None:
        ...
    def add_margin(self, arg0: float) -> None:
        ...
    def extend(self, arg0: Position) -> None:
        ...
    def get_size(self) -> Position:
        ...
class RKind:
    """
    Members:
    
      Bond
    
      Angle
    
      Torsion
    
      Chirality
    
      Plane
    """
    Angle: typing.ClassVar[RKind]  # value = <RKind.Angle: 1>
    Bond: typing.ClassVar[RKind]  # value = <RKind.Bond: 0>
    Chirality: typing.ClassVar[RKind]  # value = <RKind.Chirality: 3>
    Plane: typing.ClassVar[RKind]  # value = <RKind.Plane: 4>
    Torsion: typing.ClassVar[RKind]  # value = <RKind.Torsion: 2>
    __members__: typing.ClassVar[dict[str, RKind]]  # value = {'Bond': <RKind.Bond: 0>, 'Angle': <RKind.Angle: 1>, 'Torsion': <RKind.Torsion: 2>, 'Chirality': <RKind.Chirality: 3>, 'Plane': <RKind.Plane: 4>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ReciprocalAsu:
    def __init__(self, arg0: SpaceGroup, tnt: bool = False) -> None:
        ...
    def condition_str(self) -> str:
        ...
    def is_in(self, hkl: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> bool:
        ...
    def to_asu(self, hkl: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)], group_ops: GroupOps) -> tuple[typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)], int]:
        ...
class ReciprocalComplexGrid(ComplexGridBase):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, nx: int, ny: int, nz: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray, cell: UnitCell = None, spacegroup: SpaceGroup = None) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def calculate_1_d2(self, arg0: ComplexGridBase.Point) -> float:
        ...
    def calculate_d(self, arg0: ComplexGridBase.Point) -> float:
        ...
    def get_value(self, arg0: int, arg1: int, arg2: int) -> complex:
        ...
    def get_value_by_hkl(self, hkl: numpy.ndarray, unblur: float = 0, mott_bethe: bool = False, mott_bethe_000: complex = 0) -> numpy.ndarray:
        ...
    def get_value_or_zero(self, arg0: int, arg1: int, arg2: int) -> complex:
        ...
    def prepare_asu_data(self, dmin: float = 0.0, unblur: float = 0.0, with_000: bool = False, with_sys_abs: bool = False, mott_bethe: bool = False) -> ComplexAsuData:
        ...
    def set_value(self, arg0: int, arg1: int, arg2: int, arg3: complex) -> None:
        ...
    def to_hkl(self, arg0: ComplexGridBase.Point) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    @property
    def half_l(self) -> bool:
        ...
class ReciprocalFloatGrid(FloatGridBase):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, nx: int, ny: int, nz: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray, cell: UnitCell = None, spacegroup: SpaceGroup = None) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def calculate_1_d2(self, arg0: FloatGridBase.Point) -> float:
        ...
    def calculate_d(self, arg0: FloatGridBase.Point) -> float:
        ...
    def get_value(self, arg0: int, arg1: int, arg2: int) -> float:
        ...
    def get_value_by_hkl(self, hkl: numpy.ndarray, unblur: float = 0, mott_bethe: bool = False, mott_bethe_000: float = 0) -> numpy.ndarray:
        ...
    def get_value_or_zero(self, arg0: int, arg1: int, arg2: int) -> float:
        ...
    def prepare_asu_data(self, dmin: float = 0.0, unblur: float = 0.0, with_000: bool = False, with_sys_abs: bool = False, mott_bethe: bool = False) -> FloatAsuData:
        ...
    def set_value(self, arg0: int, arg1: int, arg2: int, arg3: float) -> None:
        ...
    def to_hkl(self, arg0: FloatGridBase.Point) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    @property
    def half_l(self) -> bool:
        ...
class ReciprocalInt8Grid(Int8GridBase):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, nx: int, ny: int, nz: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray, cell: UnitCell = None, spacegroup: SpaceGroup = None) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def calculate_1_d2(self, arg0: Int8GridBase.Point) -> float:
        ...
    def calculate_d(self, arg0: Int8GridBase.Point) -> float:
        ...
    def get_value(self, arg0: int, arg1: int, arg2: int) -> int:
        ...
    def get_value_by_hkl(self, hkl: numpy.ndarray, unblur: float = 0, mott_bethe: bool = False, mott_bethe_000: int = 0) -> numpy.ndarray:
        ...
    def get_value_or_zero(self, arg0: int, arg1: int, arg2: int) -> int:
        ...
    def prepare_asu_data(self, dmin: float = 0.0, unblur: float = 0.0, with_000: bool = False, with_sys_abs: bool = False, mott_bethe: bool = False) -> IntAsuData:
        ...
    def set_value(self, arg0: int, arg1: int, arg2: int, arg3: int) -> None:
        ...
    def to_hkl(self, arg0: Int8GridBase.Point) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    @property
    def half_l(self) -> bool:
        ...
class RefinementInfo(BasicRefinementInfo):
    class Restr:
        count: int
        dev_ideal: float
        function: str
        name: str
        weight: float
        def __init__(self, arg0: str) -> None:
            ...
    aniso_b: Mat33
    bin_count: int
    bins: list[BasicRefinementInfo]
    cc_fo_fc: float
    cc_fo_fc_free: float
    cross_validation_method: str
    dpi_blow_r: float
    dpi_blow_rfree: float
    dpi_cruickshank_r: float
    dpi_cruickshank_rfree: float
    id: str
    luzzati_error: float
    mean_b: float
    remarks: str
    restr_stats: list[RefinementInfo.Restr]
    rfree_selection_method: str
    tls_groups: list[TlsGroup]
    def __init__(self) -> None:
        ...
class ReflectionsInfo:
    completeness: float
    mean_I_over_sigma: float
    r_merge: float
    r_sym: float
    redundancy: float
    resolution_high: float
    resolution_low: float
    def __init__(self) -> None:
        ...
class ReflnBlock:
    def __bool__(self) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def column_labels(self) -> list[str]:
        ...
    def data_fits_into(self, size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> bool:
        ...
    def get_f_phi(self, f: str, phi: str, as_is: bool = False) -> ComplexAsuData:
        ...
    def get_f_phi_on_grid(self, f: str, phi: str, size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)], half_l: bool = False, order: AxisOrder = AxisOrder.XYZ) -> ReciprocalComplexGrid:
        ...
    def get_float(self, col: str, as_is: bool = False) -> FloatAsuData:
        ...
    def get_int(self, col: str, as_is: bool = False) -> IntAsuData:
        ...
    def get_size_for_hkl(self, min_size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] = [0, 0, 0], sample_rate: float = 0.0) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def get_value_on_grid(self, column: str, size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)], half_l: bool = False, order: AxisOrder = AxisOrder.XYZ) -> ReciprocalFloatGrid:
        ...
    def get_value_sigma(self, f: str, sigma: str, as_is: bool = False) -> ValueSigmaAsuData:
        ...
    def is_unmerged(self) -> bool:
        ...
    def make_1_d2_array(self) -> numpy.ndarray:
        ...
    def make_d_array(self) -> numpy.ndarray:
        ...
    def make_float_array(self, tag: str, null: float = ...) -> numpy.ndarray:
        ...
    def make_int_array(self, tag: str, null: int) -> numpy.ndarray:
        ...
    def make_miller_array(self) -> numpy.ndarray:
        ...
    def transform_f_phi_to_map(self, f: str, phi: str, min_size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] = [0, 0, 0], exact_size: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)] = [0, 0, 0], sample_rate: float = 0.0, order: AxisOrder = AxisOrder.XYZ) -> FloatGrid:
        ...
    def use_unmerged(self, arg0: bool) -> None:
        ...
    @property
    def block(self) -> cif.Block:
        ...
    @property
    def cell(self) -> UnitCell:
        ...
    @property
    def default_loop(self) -> cif.Loop:
        ...
    @property
    def entry_id(self) -> str:
        ...
    @property
    def spacegroup(self) -> SpaceGroup:
        ...
    @property
    def wavelength(self) -> float:
        ...
class ReflnBlocks:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    def __getitem__(self, arg0: int) -> ReflnBlock:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        """
        Return the canonical string representation of this list.
        """
class Residue(ResidueId):
    entity_id: str
    entity_type: EntityType
    flag: str
    het_flag: str
    label_seq: int | None
    subchain: str
    def __contains__(self, arg0: str) -> bool:
        ...
    @typing.overload
    def __delitem__(self, index: int) -> None:
        ...
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        ...
    @typing.overload
    def __getitem__(self, index: int) -> Atom:
        ...
    @typing.overload
    def __getitem__(self, name: str) -> AtomGroup:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def add_atom(self, atom: Atom, pos: int = -1) -> Atom:
        ...
    def clone(self) -> Residue:
        ...
    def find_atom(self, name: str, altloc: str, el: Element = ...) -> Atom:
        ...
    def first_conformer(self) -> FirstConformerAtoms:
        ...
    def get_ca(self) -> Atom:
        ...
    def get_p(self) -> Atom:
        ...
    def is_water(self) -> bool:
        ...
    def remove_atom(self, name: str, altloc: str, el: Element = ...) -> None:
        ...
    def remove_hydrogens(self) -> None:
        ...
    def sole_atom(self, arg0: str) -> Atom:
        ...
    def trim_to_alanine(self) -> bool:
        ...
    @property
    def sifts_unp(self) -> tuple:
        ...
class ResidueGroup(ResidueSpan):
    def __delitem__(self, name: str) -> None:
        ...
    @typing.overload
    def __getitem__(self, index: int) -> Residue:
        ...
    @typing.overload
    def __getitem__(self, name: str) -> Residue:
        ...
    def __repr__(self) -> str:
        ...
class ResidueId:
    __hash__: typing.ClassVar[None] = None
    name: str
    segment: str
    seqid: SeqId
    def __eq__(self, arg0: ResidueId) -> bool:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def __str__(self) -> str:
        ...
class ResidueInfo:
    def fasta_code(self) -> str:
        ...
    def found(self) -> bool:
        ...
    def is_amino_acid(self) -> bool:
        ...
    def is_nucleic_acid(self) -> bool:
        ...
    def is_standard(self) -> bool:
        ...
    def is_water(self) -> bool:
        ...
    @property
    def hydrogen_count(self) -> int:
        ...
    @property
    def kind(self) -> ResidueKind:
        ...
    @property
    def one_letter_code(self) -> str:
        ...
    @property
    def weight(self) -> float:
        ...
class ResidueKind:
    """
    Members:
    
      UNKNOWN
    
      AA
    
      AAD
    
      PAA
    
      MAA
    
      RNA
    
      DNA
    
      BUF
    
      HOH
    
      PYR
    
      KET
    
      ELS
    """
    AA: typing.ClassVar[ResidueKind]  # value = <ResidueKind.AA: 1>
    AAD: typing.ClassVar[ResidueKind]  # value = <ResidueKind.AAD: 2>
    BUF: typing.ClassVar[ResidueKind]  # value = <ResidueKind.BUF: 7>
    DNA: typing.ClassVar[ResidueKind]  # value = <ResidueKind.DNA: 6>
    ELS: typing.ClassVar[ResidueKind]  # value = <ResidueKind.ELS: 11>
    HOH: typing.ClassVar[ResidueKind]  # value = <ResidueKind.HOH: 8>
    KET: typing.ClassVar[ResidueKind]  # value = <ResidueKind.KET: 10>
    MAA: typing.ClassVar[ResidueKind]  # value = <ResidueKind.MAA: 4>
    PAA: typing.ClassVar[ResidueKind]  # value = <ResidueKind.PAA: 3>
    PYR: typing.ClassVar[ResidueKind]  # value = <ResidueKind.PYR: 9>
    RNA: typing.ClassVar[ResidueKind]  # value = <ResidueKind.RNA: 5>
    UNKNOWN: typing.ClassVar[ResidueKind]  # value = <ResidueKind.UNKNOWN: 0>
    __members__: typing.ClassVar[dict[str, ResidueKind]]  # value = {'UNKNOWN': <ResidueKind.UNKNOWN: 0>, 'AA': <ResidueKind.AA: 1>, 'AAD': <ResidueKind.AAD: 2>, 'PAA': <ResidueKind.PAA: 3>, 'MAA': <ResidueKind.MAA: 4>, 'RNA': <ResidueKind.RNA: 5>, 'DNA': <ResidueKind.DNA: 6>, 'BUF': <ResidueKind.BUF: 7>, 'HOH': <ResidueKind.HOH: 8>, 'PYR': <ResidueKind.PYR: 9>, 'KET': <ResidueKind.KET: 10>, 'ELS': <ResidueKind.ELS: 11>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ResidueSpan:
    def __bool__(self) -> bool:
        ...
    def __delitem__(self, index: int) -> None:
        ...
    @typing.overload
    def __getitem__(self, index: int) -> Residue:
        ...
    @typing.overload
    def __getitem__(self, pdb_seqid: str) -> ResidueGroup:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def add_residue(self, residue: Residue, pos: int = -1) -> Residue:
        ...
    def auth_seq_id_to_label(self, arg0: SeqId) -> int | None:
        ...
    def check_polymer_type(self) -> PolymerType:
        ...
    def extract_sequence(self) -> list[str]:
        ...
    def first_conformer(self) -> FirstConformerResSpan:
        ...
    def label_seq_id_to_auth(self, arg0: int | None) -> SeqId:
        ...
    def length(self) -> int:
        ...
    def make_one_letter_sequence(self) -> str:
        ...
    def residue_groups(self) -> ResidueSpanGroups:
        ...
    def subchain_id(self) -> str:
        ...
    def transform_pos_and_adp(self, arg0: Transform) -> None:
        ...
class ResidueSpanGroups:
    def __iter__(self) -> typing.Iterator:
        ...
class Restraints:
    class Angle:
        esd: float
        id1: Restraints.AtomId
        id2: Restraints.AtomId
        id3: Restraints.AtomId
        value: float
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
    class AtomId:
        atom: str
        comp: int
        @typing.overload
        def __init__(self, arg0: int, arg1: str) -> None:
            ...
        @typing.overload
        def __init__(self, arg0: str) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def get_from(self, res1: Residue, res2: Residue, altloc1: str, altloc2: str) -> Atom:
            ...
    class Bond:
        aromatic: bool
        esd: float
        esd_nucleus: float
        id1: Restraints.AtomId
        id2: Restraints.AtomId
        type: BondType
        value: float
        value_nucleus: float
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def lexicographic_str(self) -> str:
            ...
    class Chirality:
        id1: Restraints.AtomId
        id2: Restraints.AtomId
        id3: Restraints.AtomId
        id_ctr: Restraints.AtomId
        sign: ChiralityType
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def is_wrong(self, arg0: float) -> bool:
            ...
    class DistanceOf:
        """
        Members:
        
          ElectronCloud
        
          Nucleus
        """
        ElectronCloud: typing.ClassVar[Restraints.DistanceOf]  # value = <DistanceOf.ElectronCloud: 0>
        Nucleus: typing.ClassVar[Restraints.DistanceOf]  # value = <DistanceOf.Nucleus: 1>
        __members__: typing.ClassVar[dict[str, Restraints.DistanceOf]]  # value = {'ElectronCloud': <DistanceOf.ElectronCloud: 0>, 'Nucleus': <DistanceOf.Nucleus: 1>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    class Plane:
        esd: float
        ids: list[Restraints.AtomId]
        label: str
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
    class Torsion:
        esd: float
        id1: Restraints.AtomId
        id2: Restraints.AtomId
        id3: Restraints.AtomId
        id4: Restraints.AtomId
        label: str
        period: int
        value: float
        def __init__(self) -> None:
            ...
        def __repr__(self) -> str:
            ...
    angles: RestraintsAngles
    bonds: RestraintsBonds
    chirs: RestraintsChirs
    planes: RestraintsPlanes
    torsions: RestraintsTorsions
    def __init__(self) -> None:
        ...
    def chiral_abs_volume(self, arg0: Restraints.Chirality) -> float:
        ...
    def empty(self) -> bool:
        ...
    def find_shortest_path(self, arg0: Restraints.AtomId, arg1: Restraints.AtomId, arg2: list[Restraints.AtomId]) -> list[Restraints.AtomId]:
        ...
    @typing.overload
    def get_bond(self, arg0: Restraints.AtomId, arg1: Restraints.AtomId) -> Restraints.Bond:
        ...
    @typing.overload
    def get_bond(self, arg0: str, arg1: str) -> Restraints.Bond:
        ...
class RestraintsAngles:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> RestraintsAngles:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Restraints.Angle:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: RestraintsAngles) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Restraints.Angle) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: RestraintsAngles) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Restraints.Angle) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: RestraintsAngles) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Restraints.Angle) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Restraints.Angle:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Restraints.Angle:
        """
        Remove and return the item at index ``i``
        """
class RestraintsBonds:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> RestraintsBonds:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Restraints.Bond:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: RestraintsBonds) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Restraints.Bond) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: RestraintsBonds) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Restraints.Bond) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: RestraintsBonds) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Restraints.Bond) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Restraints.Bond:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Restraints.Bond:
        """
        Remove and return the item at index ``i``
        """
class RestraintsChirs:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> RestraintsChirs:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Restraints.Chirality:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: RestraintsChirs) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Restraints.Chirality) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: RestraintsChirs) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Restraints.Chirality) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: RestraintsChirs) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Restraints.Chirality) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Restraints.Chirality:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Restraints.Chirality:
        """
        Remove and return the item at index ``i``
        """
class RestraintsPlanes:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> RestraintsPlanes:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Restraints.Plane:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: RestraintsPlanes) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Restraints.Plane) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: RestraintsPlanes) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Restraints.Plane) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: RestraintsPlanes) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Restraints.Plane) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Restraints.Plane:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Restraints.Plane:
        """
        Remove and return the item at index ``i``
        """
class RestraintsTorsions:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> RestraintsTorsions:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Restraints.Torsion:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: RestraintsTorsions) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Restraints.Torsion) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: RestraintsTorsions) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Restraints.Torsion) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: RestraintsTorsions) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Restraints.Torsion) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Restraints.Torsion:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Restraints.Torsion:
        """
        Remove and return the item at index ``i``
        """
class SMat33d:
    u11: float
    u12: float
    u13: float
    u22: float
    u23: float
    u33: float
    def __add__(self, arg0: SMat33d) -> SMat33d:
        ...
    def __init__(self, u11: float, u22: float, u33: float, u12: float, u13: float, u23: float) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __sub__(self, arg0: SMat33d) -> SMat33d:
        ...
    def added_kI(self, arg0: float) -> SMat33d:
        ...
    def as_mat33(self) -> Mat33:
        ...
    def calculate_eigenvalues(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def determinant(self) -> float:
        ...
    def elements_pdb(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    def elements_voigt(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    def inverse(self) -> SMat33d:
        ...
    def multiply(self, arg0: Vec3) -> Vec3:
        ...
    def nonzero(self) -> bool:
        ...
    @typing.overload
    def r_u_r(self, arg0: Vec3) -> float:
        ...
    @typing.overload
    def r_u_r(self, arg0: numpy.ndarray) -> numpy.ndarray:
        ...
    def scaled(self, arg0: float) -> SMat33d:
        ...
    def trace(self) -> float:
        ...
    def transformed_by(self, arg0: Mat33) -> SMat33d:
        ...
class SMat33f:
    u11: float
    u12: float
    u13: float
    u22: float
    u23: float
    u33: float
    def __add__(self, arg0: SMat33f) -> SMat33f:
        ...
    def __init__(self, u11: float, u22: float, u33: float, u12: float, u13: float, u23: float) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __sub__(self, arg0: SMat33f) -> SMat33f:
        ...
    def added_kI(self, arg0: float) -> SMat33f:
        ...
    def as_mat33(self) -> Mat33:
        ...
    def calculate_eigenvalues(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def determinant(self) -> float:
        ...
    def elements_pdb(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    def elements_voigt(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]:
        ...
    def inverse(self) -> SMat33f:
        ...
    def multiply(self, arg0: Vec3) -> Vec3:
        ...
    def nonzero(self) -> bool:
        ...
    @typing.overload
    def r_u_r(self, arg0: Vec3) -> float:
        ...
    @typing.overload
    def r_u_r(self, arg0: numpy.ndarray) -> numpy.ndarray:
        ...
    def scaled(self, arg0: float) -> SMat33f:
        ...
    def trace(self) -> float:
        ...
    def transformed_by(self, arg0: Mat33) -> SMat33f:
        ...
class Scaling:
    b_overall: SMat33d
    b_sol: float
    cell: UnitCell
    k_overall: float
    k_sol: float
    use_solvent: bool
    def __init__(self, arg0: UnitCell, arg1: SpaceGroup) -> None:
        ...
    def fit_isotropic_b_approximately(self) -> None:
        ...
    def fit_parameters(self) -> None:
        ...
    @typing.overload
    def get_overall_scale_factor(self, hkl: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> float:
        ...
    @typing.overload
    def get_overall_scale_factor(self, arg0: numpy.ndarray) -> numpy.ndarray:
        ...
    def get_solvent_scale(self, stol2: numpy.ndarray) -> typing.Any:
        ...
    def prepare_points(self, calc: ComplexAsuData, obs: ValueSigmaAsuData, mask: ComplexAsuData = None) -> None:
        ...
    def scale_data(self, asu_data: ComplexAsuData, mask_data: ComplexAsuData = None) -> None:
        ...
    def scale_value(self, hkl: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)], f_value: complex, mask_value: complex) -> complex:
        ...
class Selection:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: str) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def atoms(self, arg0: Residue) -> SelectionAtomsProxy:
        ...
    def chains(self, arg0: Model) -> SelectionChainsProxy:
        ...
    def copy_model_selection(self, arg0: Model) -> Model:
        ...
    def copy_structure_selection(self, arg0: Structure) -> Structure:
        ...
    def first(self, arg0: Structure) -> tuple[Model, CRA]:
        ...
    def first_in_model(self, arg0: Model) -> CRA:
        ...
    def models(self, arg0: Structure) -> SelectionModelsProxy:
        ...
    @typing.overload
    def remove_not_selected(self, arg0: Structure) -> None:
        ...
    @typing.overload
    def remove_not_selected(self, arg0: Model) -> None:
        ...
    @typing.overload
    def remove_selected(self, arg0: Structure) -> None:
        ...
    @typing.overload
    def remove_selected(self, arg0: Model) -> None:
        ...
    def residues(self, arg0: Chain) -> SelectionResiduesProxy:
        ...
    def set_atom_flags(self, arg0: str) -> Selection:
        ...
    def set_residue_flags(self, arg0: str) -> Selection:
        ...
    def str(self) -> str:
        ...
class SelectionAtomsProxy:
    def __iter__(self) -> typing.Iterator:
        ...
class SelectionChainsProxy:
    def __iter__(self) -> typing.Iterator:
        ...
class SelectionModelsProxy:
    def __iter__(self) -> typing.Iterator:
        ...
class SelectionResiduesProxy:
    def __iter__(self) -> typing.Iterator:
        ...
class SellingVector:
    @typing.overload
    def __init__(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: UnitCell, arg1: SpaceGroup) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def cell_parameters(self) -> tuple:
        ...
    def get_cell(self) -> UnitCell:
        ...
    def gruber(self) -> GruberVector:
        ...
    def is_reduced(self, epsilon: float = 1e-09) -> bool:
        ...
    def reduce(self, epsilon: float = 1e-09, iteration_limit: int = 100) -> int:
        ...
    def reduce_step(self, epsilon: float = 1e-09) -> bool:
        ...
    def sort(self, epsilon: float = 1e-09) -> None:
        ...
    def sum_b_squared(self) -> float:
        ...
    @property
    def parameters(self) -> tuple:
        ...
class SeqId:
    __hash__: typing.ClassVar[None] = None
    icode: str
    num: int | None
    def __eq__(self, arg0: SeqId) -> bool:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, arg0: int, arg1: str) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: str) -> None:
        ...
    def __lt__(self, arg0: SeqId) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def __str__(self) -> str:
        ...
class Sheet:
    class Strand:
        end: AtomAddress
        hbond_atom1: AtomAddress
        hbond_atom2: AtomAddress
        name: str
        sense: int
        start: AtomAddress
        def __init__(self) -> None:
            ...
    class StrandList:
        def __bool__(self) -> bool:
            """
            Check whether the list is nonempty
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None:
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None:
            """
            Delete list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, s: slice) -> Sheet.StrandList:
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> Sheet.Strand:
            ...
        @typing.overload
        def __init__(self) -> None:
            ...
        @typing.overload
        def __init__(self, arg0: Sheet.StrandList) -> None:
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None:
            ...
        def __iter__(self) -> typing.Iterator:
            ...
        def __len__(self) -> int:
            ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: Sheet.Strand) -> None:
            ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: Sheet.StrandList) -> None:
            """
            Assign list elements using a slice object
            """
        def append(self, x: Sheet.Strand) -> None:
            """
            Add an item to the end of the list
            """
        def clear(self) -> None:
            """
            Clear the contents
            """
        @typing.overload
        def extend(self, L: Sheet.StrandList) -> None:
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None:
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: Sheet.Strand) -> None:
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> Sheet.Strand:
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> Sheet.Strand:
            """
            Remove and return the item at index ``i``
            """
    name: str
    strands: Sheet.StrandList
    def __init__(self, arg0: str) -> None:
        ...
class SheetList:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> SheetList:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Sheet:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: SheetList) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Sheet) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: SheetList) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Sheet) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: SheetList) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Sheet) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Sheet:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Sheet:
        """
        Remove and return the item at index ``i``
        """
class SmallStructure:
    class AtomType:
        dispersion_imag: float
        dispersion_real: float
        def __repr__(self) -> str:
            ...
        @property
        def element(self) -> Element:
            ...
        @property
        def symbol(self) -> str:
            ...
    class Site:
        aniso: SMat33d
        charge: int
        disorder_group: int
        element: Element
        fract: Fractional
        label: str
        occ: float
        type_symbol: str
        u_iso: float
        @typing.overload
        def __init__(self) -> None:
            ...
        @typing.overload
        def __init__(self, arg0: Atom, arg1: UnitCell) -> None:
            ...
        def __repr__(self) -> str:
            ...
        def orth(self, arg0: UnitCell) -> Position:
            ...
    class SiteList:
        def __bool__(self) -> bool:
            """
            Check whether the list is nonempty
            """
        @typing.overload
        def __delitem__(self, arg0: int) -> None:
            """
            Delete the list elements at index ``i``
            """
        @typing.overload
        def __delitem__(self, arg0: slice) -> None:
            """
            Delete list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, s: slice) -> SmallStructure.SiteList:
            """
            Retrieve list elements using a slice object
            """
        @typing.overload
        def __getitem__(self, arg0: int) -> SmallStructure.Site:
            ...
        @typing.overload
        def __init__(self) -> None:
            ...
        @typing.overload
        def __init__(self, arg0: SmallStructure.SiteList) -> None:
            """
            Copy constructor
            """
        @typing.overload
        def __init__(self, arg0: typing.Iterable) -> None:
            ...
        def __iter__(self) -> typing.Iterator:
            ...
        def __len__(self) -> int:
            ...
        @typing.overload
        def __setitem__(self, arg0: int, arg1: SmallStructure.Site) -> None:
            ...
        @typing.overload
        def __setitem__(self, arg0: slice, arg1: SmallStructure.SiteList) -> None:
            """
            Assign list elements using a slice object
            """
        def append(self, x: SmallStructure.Site) -> None:
            """
            Add an item to the end of the list
            """
        def clear(self) -> None:
            """
            Clear the contents
            """
        @typing.overload
        def extend(self, L: SmallStructure.SiteList) -> None:
            """
            Extend the list by appending all the items in the given list
            """
        @typing.overload
        def extend(self, L: typing.Iterable) -> None:
            """
            Extend the list by appending all the items in the given list
            """
        def insert(self, i: int, x: SmallStructure.Site) -> None:
            """
            Insert an item at a given position.
            """
        @typing.overload
        def pop(self) -> SmallStructure.Site:
            """
            Remove and return the last item
            """
        @typing.overload
        def pop(self, i: int) -> SmallStructure.Site:
            """
            Remove and return the item at index ``i``
            """
    cell: UnitCell
    name: str
    spacegroup_hm: str
    wavelength: float
    def __init__(self) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def add_site(self, arg0: SmallStructure.Site) -> None:
        ...
    def change_occupancies_to_crystallographic(self, max_dist: float = 0.4) -> None:
        ...
    def find_spacegroup(self) -> SpaceGroup:
        ...
    def get_all_unit_cell_sites(self) -> SmallStructure.SiteList:
        ...
    def get_atom_type(self, arg0: str) -> SmallStructure.AtomType:
        ...
    def make_cif_block(self) -> cif.Block:
        ...
    def remove_hydrogens(self) -> None:
        ...
    def setup_cell_images(self) -> None:
        ...
    @property
    def atom_types(self) -> list[SmallStructure.AtomType]:
        ...
    @property
    def sites(self) -> SmallStructure.SiteList:
        ...
class SoftwareItem:
    class Classification:
        """
        Members:
        
          DataCollection
        
          DataExtraction
        
          DataProcessing
        
          DataReduction
        
          DataScaling
        
          ModelBuilding
        
          Phasing
        
          Refinement
        
          Unspecified
        """
        DataCollection: typing.ClassVar[SoftwareItem.Classification]  # value = <Classification.DataCollection: 0>
        DataExtraction: typing.ClassVar[SoftwareItem.Classification]  # value = <Classification.DataExtraction: 1>
        DataProcessing: typing.ClassVar[SoftwareItem.Classification]  # value = <Classification.DataProcessing: 2>
        DataReduction: typing.ClassVar[SoftwareItem.Classification]  # value = <Classification.DataReduction: 3>
        DataScaling: typing.ClassVar[SoftwareItem.Classification]  # value = <Classification.DataScaling: 4>
        ModelBuilding: typing.ClassVar[SoftwareItem.Classification]  # value = <Classification.ModelBuilding: 5>
        Phasing: typing.ClassVar[SoftwareItem.Classification]  # value = <Classification.Phasing: 6>
        Refinement: typing.ClassVar[SoftwareItem.Classification]  # value = <Classification.Refinement: 7>
        Unspecified: typing.ClassVar[SoftwareItem.Classification]  # value = <Classification.Unspecified: 8>
        __members__: typing.ClassVar[dict[str, SoftwareItem.Classification]]  # value = {'DataCollection': <Classification.DataCollection: 0>, 'DataExtraction': <Classification.DataExtraction: 1>, 'DataProcessing': <Classification.DataProcessing: 2>, 'DataReduction': <Classification.DataReduction: 3>, 'DataScaling': <Classification.DataScaling: 4>, 'ModelBuilding': <Classification.ModelBuilding: 5>, 'Phasing': <Classification.Phasing: 6>, 'Refinement': <Classification.Refinement: 7>, 'Unspecified': <Classification.Unspecified: 8>}
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    classification: SoftwareItem.Classification
    date: str
    name: str
    version: str
    def __init__(self) -> None:
        ...
class SolventMasker:
    atomic_radii_set: AtomicRadiiSet
    constant_r: float
    ignore_hydrogen: bool
    ignore_zero_occupancy_atoms: bool
    island_min_volume: float
    rprobe: float
    rshrink: float
    def __init__(self, choice: AtomicRadiiSet, constant_r: float = 0.0) -> None:
        ...
    def put_mask_on_float_grid(self, arg0: FloatGrid, arg1: Model) -> None:
        ...
    def put_mask_on_int8_grid(self, arg0: Int8Grid, arg1: Model) -> None:
        ...
    def set_radii(self, choice: AtomicRadiiSet, constant_r: float = 0.0) -> None:
        ...
    def set_to_zero(self, arg0: FloatGrid, arg1: Model) -> None:
        ...
class SpaceGroup:
    __hash__: typing.ClassVar[None] = None
    def __eq__(self, arg0: SpaceGroup) -> bool:
        ...
    def __getstate__(self) -> str:
        ...
    @typing.overload
    def __init__(self, ccp4: int) -> None:
        ...
    @typing.overload
    def __init__(self, hm: str) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: str) -> None:
        ...
    def centred_to_primitive(self) -> Op:
        ...
    def centring_type(self) -> str:
        ...
    def change_of_hand_op(self) -> Op:
        ...
    def crystal_system(self) -> CrystalSystem:
        ...
    def crystal_system_str(self) -> str:
        """
        Returns lower-case name of the crystal system.
        """
    def is_centrosymmetric(self) -> bool:
        ...
    def is_enantiomorphic(self) -> bool:
        ...
    def is_reference_setting(self) -> bool:
        ...
    def is_sohncke(self) -> bool:
        ...
    def is_symmorphic(self) -> bool:
        ...
    def laue_str(self) -> str:
        """
        Returns name of the Laue class (for centrosymmetric groups the same as point_group_hm).
        """
    def operations(self) -> GroupOps:
        """
        Group of operations
        """
    def point_group_hm(self) -> str:
        """
        Returns H-M name of the point group.
        """
    def short_name(self) -> str:
        """
        H-M name w/o spaces and with 1's removed in '1 ... 1'.
        """
    def switch_to_asu(self, miller_array: numpy.ndarray) -> None:
        ...
    def xhm(self) -> str:
        """
        extended Hermann-Mauguin name
        """
    @property
    def basisop(self) -> Op:
        ...
    @property
    def ccp4(self) -> int:
        """
        ccp4 number
        """
    @property
    def ext(self) -> str:
        """
        Extension (1, 2, H, R or none)
        """
    @property
    def hall(self) -> str:
        """
        Hall symbol
        """
    @property
    def hm(self) -> str:
        """
        Hermann-Mauguin name
        """
    @property
    def number(self) -> int:
        """
        number 1-230.
        """
    @property
    def qualifier(self) -> str:
        """
        e.g. 'cab'
        """
class Structure:
    assemblies: AssemblyList
    cell: UnitCell
    cispeps: list[CisPep]
    connections: ConnectionList
    entities: EntityList
    has_d_fraction: bool
    has_origx: bool
    helices: HelixList
    info: InfoMap
    input_format: CoorFormat
    meta: Metadata
    mod_residues: list[ModRes]
    name: str
    ncs: NcsOpList
    raw_remarks: list[str]
    resolution: float
    sheets: SheetList
    shortened_ccd_codes: list[tuple[str, str]]
    spacegroup_hm: str
    @typing.overload
    def __delitem__(self, index: int) -> None:
        ...
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        ...
    @typing.overload
    def __delitem__(self, name: str) -> None:
        ...
    @typing.overload
    def __getitem__(self, index: int) -> Model:
        ...
    @typing.overload
    def __getitem__(self, name: str) -> Model:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: Model) -> None:
        ...
    def add_conect(self, serial1: int, serial2: int, order: int) -> None:
        ...
    def add_entity_ids(self, overwrite: bool = False) -> None:
        ...
    def add_entity_types(self, overwrite: bool = False) -> None:
        ...
    def add_model(self, model: Model, pos: int = -1) -> Model:
        ...
    def assign_best_sequences(self, fasta_sequences: list[str]) -> None:
        ...
    def assign_label_seq_id(self, force: bool = False) -> None:
        ...
    def assign_serial_numbers(self, numbered_ter: bool = False) -> None:
        ...
    def assign_subchains(self, force: bool = False, fail_if_unknown: bool = True) -> None:
        ...
    def calculate_box(self, margin: float = 0.0) -> PositionBox:
        ...
    def calculate_fractional_box(self, margin: float = 0.0) -> FractionalBox:
        ...
    def clear_conect(self) -> None:
        ...
    def clear_sequences(self) -> None:
        ...
    def clone(self) -> Structure:
        ...
    def deduplicate_entities(self) -> None:
        ...
    def ensure_entities(self) -> None:
        ...
    def expand_ncs(self, how: HowToNameCopiedChain, merge_dist: float = 0.2) -> None:
        ...
    def find_connection(self, partner1: AtomAddress, partner2: AtomAddress) -> Connection:
        ...
    def find_connection_by_cra(self, cra1: CRA, cra2: CRA, ignore_segment: bool = False) -> Connection:
        ...
    def find_or_add_model(self, name: str) -> Model:
        ...
    def find_spacegroup(self) -> SpaceGroup:
        ...
    def get_entity(self, subchain: str) -> Entity:
        ...
    def get_entity_of(self, subchain: ResidueSpan) -> Entity:
        ...
    def make_minimal_pdb(self) -> str:
        ...
    def make_mmcif_block(self, groups: MmcifOutputGroups = ...) -> cif.Block:
        ...
    def make_mmcif_document(self, groups: MmcifOutputGroups = ...) -> cif.Document:
        ...
    def make_mmcif_headers(self) -> cif.Block:
        ...
    def make_pdb_headers(self) -> str:
        ...
    def make_pdb_string(self, options: PdbWriteOptions = ...) -> str:
        ...
    def merge_chain_parts(self, min_sep: int = 0) -> None:
        ...
    def remove_alternative_conformations(self) -> None:
        ...
    def remove_empty_chains(self) -> None:
        ...
    def remove_hydrogens(self) -> None:
        ...
    def remove_ligands_and_waters(self) -> None:
        ...
    def remove_waters(self) -> None:
        ...
    def renumber_models(self) -> None:
        ...
    def restore_full_ccd_codes(self) -> None:
        ...
    def setup_cell_images(self) -> None:
        ...
    def setup_entities(self) -> None:
        ...
    def shorten_ccd_codes(self) -> None:
        ...
    def shorten_chain_names(self) -> None:
        ...
    def standardize_crystal_frame(self) -> None:
        ...
    def store_deuterium_as_fraction(self, arg0: bool) -> None:
        ...
    def transform_to_assembly(self, assembly_name: str, how: HowToNameCopiedChain, keep_spacegroup: bool = False, merge_dist: float = 0.2) -> None:
        ...
    def update_mmcif_block(self, block: cif.Block, groups: MmcifOutputGroups = ...) -> None:
        ...
    def write_minimal_pdb(self, path: str) -> None:
        ...
    @typing.overload
    def write_pdb(self, arg0: str, arg1: PdbWriteOptions) -> None:
        ...
    @typing.overload
    def write_pdb(self, path: str, **kwargs) -> None:
        ...
    @property
    def origx(self) -> Transform:
        ...
class StructureFactorCalculatorE:
    addends: Addends
    def __init__(self, arg0: UnitCell) -> None:
        ...
    def calculate_sf_from_model(self, arg0: Model, arg1: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> complex:
        ...
    def calculate_sf_from_small_structure(self, arg0: SmallStructure, arg1: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> complex:
        ...
class StructureFactorCalculatorN:
    addends: Addends
    def __init__(self, arg0: UnitCell) -> None:
        ...
    def calculate_sf_from_model(self, arg0: Model, arg1: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> complex:
        ...
    def calculate_sf_from_small_structure(self, arg0: SmallStructure, arg1: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> complex:
        ...
class StructureFactorCalculatorX:
    addends: Addends
    def __init__(self, arg0: UnitCell) -> None:
        ...
    def calculate_mb_z(self, model: Model, hkl: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)], only_h: bool = False) -> complex:
        ...
    def calculate_sf_from_model(self, arg0: Model, arg1: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> complex:
        ...
    def calculate_sf_from_small_structure(self, arg0: SmallStructure, arg1: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> complex:
        ...
    def mott_bethe_factor(self) -> float:
        ...
class SupResult:
    @property
    def center1(self) -> Position:
        ...
    @property
    def center2(self) -> Position:
        ...
    @property
    def count(self) -> int:
        ...
    @property
    def rmsd(self) -> float:
        ...
    @property
    def transform(self) -> Transform:
        ...
class SupSelect:
    """
    Members:
    
      CaP
    
      MainChain
    
      All
    """
    All: typing.ClassVar[SupSelect]  # value = <SupSelect.All: 2>
    CaP: typing.ClassVar[SupSelect]  # value = <SupSelect.CaP: 0>
    MainChain: typing.ClassVar[SupSelect]  # value = <SupSelect.MainChain: 1>
    __members__: typing.ClassVar[dict[str, SupSelect]]  # value = {'CaP': <SupSelect.CaP: 0>, 'MainChain': <SupSelect.MainChain: 1>, 'All': <SupSelect.All: 2>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class TlsGroup:
    class Selection:
        chain: str
        details: str
        res_begin: SeqId
        res_end: SeqId
        def __init__(self) -> None:
            ...
    L: Mat33
    S: Mat33
    T: Mat33
    id: str
    origin: Position
    selections: list[TlsGroup.Selection]
    def __init__(self) -> None:
        ...
class Topo:
    class Angle:
        def calculate(self) -> float:
            ...
        def calculate_z(self) -> float:
            ...
        @property
        def atoms(self) -> typing.Annotated[list[Atom], pybind11_stubgen.typing_ext.FixedSize(3)]:
            ...
        @property
        def restr(self) -> Restraints.Angle:
            ...
    class Bond:
        def calculate(self) -> float:
            ...
        def calculate_z(self) -> float:
            ...
        @property
        def atoms(self) -> typing.Annotated[list[Atom], pybind11_stubgen.typing_ext.FixedSize(2)]:
            ...
        @property
        def restr(self) -> Restraints.Bond:
            ...
    class ChainInfo:
        @property
        def chain_ref(self) -> Chain:
            ...
        @property
        def entity_id(self) -> str:
            ...
        @property
        def polymer(self) -> bool:
            ...
        @property
        def polymer_type(self) -> PolymerType:
            ...
        @property
        def res_infos(self) -> TopoResInfos:
            ...
        @property
        def subchain_name(self) -> str:
            ...
    class Chirality:
        def calculate(self) -> float:
            ...
        def calculate_z(self, ideal_abs_vol: float, esd: float) -> float:
            ...
        def check(self) -> bool:
            ...
        @property
        def atoms(self) -> typing.Annotated[list[Atom], pybind11_stubgen.typing_ext.FixedSize(4)]:
            ...
        @property
        def restr(self) -> Restraints.Chirality:
            ...
    class FinalChemComp:
        @property
        def altloc(self) -> str:
            ...
        @property
        def cc(self) -> ChemComp:
            ...
    class Link:
        @property
        def alt1(self) -> str:
            ...
        @property
        def alt2(self) -> str:
            ...
        @property
        def link_id(self) -> str:
            ...
        @property
        def link_rules(self) -> TopoRules:
            ...
        @property
        def res1(self) -> Residue:
            ...
        @property
        def res2(self) -> Residue:
            ...
    class Mod:
        @property
        def alias(self) -> ChemComp.Group:
            ...
        @property
        def altloc(self) -> str:
            ...
        @property
        def id(self) -> str:
            ...
    class Plane:
        def has(self, arg0: Atom) -> bool:
            ...
        @property
        def atoms(self) -> list[Atom]:
            ...
        @property
        def restr(self) -> Restraints.Plane:
            ...
    class ResInfo:
        def get_final_chemcomp(self, arg0: str) -> ChemComp:
            ...
        @property
        def chemcomps(self) -> TopoFinalChemComps:
            ...
        @property
        def mods(self) -> TopoMods:
            ...
        @property
        def monomer_rules(self) -> TopoRules:
            ...
        @property
        def prev(self) -> TopoLinks:
            ...
        @property
        def res(self) -> Residue:
            ...
    class Rule:
        @property
        def index(self) -> int:
            ...
        @property
        def rkind(self) -> RKind:
            ...
    class Torsion:
        def calculate(self) -> float:
            ...
        def calculate_z(self) -> float:
            ...
        @property
        def atoms(self) -> typing.Annotated[list[Atom], pybind11_stubgen.typing_ext.FixedSize(4)]:
            ...
        @property
        def restr(self) -> Restraints.Torsion:
            ...
    def __init__(self) -> None:
        ...
    def adjust_hydrogen_distances(self, of: Restraints.DistanceOf, default_scale: float = 1.0) -> None:
        ...
    def find_missing_atoms(self, including_hydrogen: bool = False) -> list[AtomAddress]:
        ...
    def first_bond_in_link(self, arg0: Topo.Link) -> Topo.Bond:
        ...
    def ideal_chiral_abs_volume(self, arg0: Topo.Chirality) -> float:
        ...
    def links_to_previous(self, arg0: Residue) -> TopoLinks:
        ...
    def set_cispeps_in_structure(self, arg0: Structure) -> None:
        ...
    @property
    def angles(self) -> TopoAngles:
        ...
    @property
    def bonds(self) -> TopoBonds:
        ...
    @property
    def chain_infos(self) -> TopoChainInfos:
        ...
    @property
    def chirs(self) -> TopoChirs:
        ...
    @property
    def extras(self) -> TopoLinks:
        ...
    @property
    def planes(self) -> TopoPlanes:
        ...
    @property
    def torsions(self) -> TopoTorsions:
        ...
class TopoAngles:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> TopoAngles:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Topo.Angle:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: TopoAngles) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Topo.Angle) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: TopoAngles) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Topo.Angle) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: TopoAngles) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Topo.Angle) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Topo.Angle:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Topo.Angle:
        """
        Remove and return the item at index ``i``
        """
class TopoBonds:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> TopoBonds:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Topo.Bond:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: TopoBonds) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Topo.Bond) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: TopoBonds) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Topo.Bond) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: TopoBonds) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Topo.Bond) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Topo.Bond:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Topo.Bond:
        """
        Remove and return the item at index ``i``
        """
class TopoChainInfos:
    def __getitem__(self, arg0: int) -> Topo.ChainInfo:
        ...
    def __len__(self) -> int:
        ...
class TopoChirs:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> TopoChirs:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Topo.Chirality:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: TopoChirs) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Topo.Chirality) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: TopoChirs) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Topo.Chirality) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: TopoChirs) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Topo.Chirality) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Topo.Chirality:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Topo.Chirality:
        """
        Remove and return the item at index ``i``
        """
class TopoFinalChemComps:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> TopoFinalChemComps:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Topo.FinalChemComp:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: TopoFinalChemComps) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Topo.FinalChemComp) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: TopoFinalChemComps) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Topo.FinalChemComp) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: TopoFinalChemComps) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Topo.FinalChemComp) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Topo.FinalChemComp:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Topo.FinalChemComp:
        """
        Remove and return the item at index ``i``
        """
class TopoLinks:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> TopoLinks:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Topo.Link:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: TopoLinks) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Topo.Link) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: TopoLinks) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Topo.Link) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: TopoLinks) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Topo.Link) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Topo.Link:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Topo.Link:
        """
        Remove and return the item at index ``i``
        """
class TopoMods:
    __hash__: typing.ClassVar[None] = None
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: Topo.Mod) -> bool:
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: TopoMods) -> bool:
        ...
    @typing.overload
    def __getitem__(self, s: slice) -> TopoMods:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Topo.Mod:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: TopoMods) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __ne__(self, arg0: TopoMods) -> bool:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Topo.Mod) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: TopoMods) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Topo.Mod) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    def count(self, x: Topo.Mod) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: TopoMods) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Topo.Mod) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Topo.Mod:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Topo.Mod:
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: Topo.Mod) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
class TopoPlanes:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> TopoPlanes:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Topo.Plane:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: TopoPlanes) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Topo.Plane) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: TopoPlanes) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Topo.Plane) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: TopoPlanes) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Topo.Plane) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Topo.Plane:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Topo.Plane:
        """
        Remove and return the item at index ``i``
        """
class TopoResInfos:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> TopoResInfos:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Topo.ResInfo:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: TopoResInfos) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Topo.ResInfo) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: TopoResInfos) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Topo.ResInfo) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: TopoResInfos) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Topo.ResInfo) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Topo.ResInfo:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Topo.ResInfo:
        """
        Remove and return the item at index ``i``
        """
class TopoRules:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> TopoRules:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Topo.Rule:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: TopoRules) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Topo.Rule) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: TopoRules) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Topo.Rule) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: TopoRules) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Topo.Rule) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Topo.Rule:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Topo.Rule:
        """
        Remove and return the item at index ``i``
        """
class TopoTorsions:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> TopoTorsions:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> Topo.Torsion:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: TopoTorsions) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: Topo.Torsion) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: TopoTorsions) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: Topo.Torsion) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: TopoTorsions) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: Topo.Torsion) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> Topo.Torsion:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> Topo.Torsion:
        """
        Remove and return the item at index ``i``
        """
class Transform:
    @staticmethod
    def __matmul__(*args, **kwargs):
        """
        combine(self: gemmi.Transform, arg0: gemmi.Transform) -> gemmi.Transform
        """
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, mat33: Mat33, vec3: Vec3) -> None:
        ...
    def apply(self, arg0: Vec3) -> Vec3:
        ...
    def approx(self, other: Transform, epsilon: float) -> bool:
        ...
    def combine(self, arg0: Transform) -> Transform:
        ...
    def inverse(self) -> Transform:
        ...
    def is_identity(self) -> bool:
        ...
    @property
    def mat(self) -> Mat33:
        ...
    @property
    def vec(self) -> Vec3:
        ...
class UnitCell:
    __hash__: typing.ClassVar[None] = None
    def __eq__(self, arg0: UnitCell) -> bool:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, a: float, b: float, c: float, alpha: float, beta: float, gamma: float) -> None:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def approx(self, other: UnitCell, epsilon: float) -> bool:
        ...
    def calculate_1_d2(self, hkl: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> float:
        ...
    def calculate_1_d2_array(self, arg0: numpy.ndarray) -> numpy.ndarray:
        ...
    def calculate_d(self, hkl: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]) -> float:
        ...
    def calculate_d_array(self, arg0: numpy.ndarray) -> numpy.ndarray:
        ...
    def calculate_u_eq(self, arg0: SMat33d) -> float:
        ...
    def changed_basis_backward(self, op: Op, set_images: bool) -> UnitCell:
        ...
    def changed_basis_forward(self, op: Op, set_images: bool) -> UnitCell:
        ...
    def find_nearest_image(self, ref: Position, pos: Position, asu: Asu = Asu.Any) -> NearestImage:
        ...
    @typing.overload
    def find_nearest_pbc_image(self, fref: Fractional, fpos: Fractional, image_idx: int) -> NearestImage:
        ...
    @typing.overload
    def find_nearest_pbc_image(self, ref: Position, pos: Position, image_idx: int) -> NearestImage:
        ...
    def find_nearest_pbc_position(self, ref: Position, pos: Position, image_idx: int, inverse: bool = False) -> Position:
        ...
    def fractionalize(self, arg0: Position) -> Fractional:
        ...
    def get_hkl_limits(self, dmin: float) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
    def is_compatible_with_spacegroup(self, sg: SpaceGroup, eps: float = 0.001) -> bool:
        ...
    def is_crystal(self) -> bool:
        ...
    def is_similar(self, other: UnitCell, rel: float, deg: float) -> bool:
        ...
    @typing.overload
    def is_special_position(self, pos: Position, max_dist: float = 0.8) -> int:
        ...
    @typing.overload
    def is_special_position(self, fpos: Fractional, max_dist: float) -> int:
        ...
    def metric_tensor(self) -> SMat33d:
        ...
    def op_as_transform(self, arg0: Op) -> Transform:
        ...
    def orthogonalize(self, arg0: Fractional) -> Position:
        ...
    def orthogonalize_box(self, arg0: FractionalBox) -> PositionBox:
        ...
    def primitive_orth_matrix(self, centring_type: str) -> Mat33:
        ...
    def reciprocal(self) -> UnitCell:
        ...
    def reciprocal_metric_tensor(self) -> SMat33d:
        ...
    def set(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float) -> None:
        ...
    def volume_per_image(self) -> float:
        ...
    @property
    def a(self) -> float:
        ...
    @property
    def alpha(self) -> float:
        ...
    @property
    def b(self) -> float:
        ...
    @property
    def beta(self) -> float:
        ...
    @property
    def c(self) -> float:
        ...
    @property
    def explicit_matrices(self) -> bool:
        ...
    @property
    def frac(self) -> Transform:
        ...
    @property
    def fractionalization_matrix(self) -> Mat33:
        ...
    @property
    def gamma(self) -> float:
        ...
    @property
    def images(self) -> list[FTransform]:
        ...
    @property
    def orth(self) -> Transform:
        ...
    @property
    def orthogonalization_matrix(self) -> Mat33:
        ...
    @property
    def parameters(self) -> tuple:
        ...
    @property
    def volume(self) -> float:
        ...
class ValueSigma:
    sigma: float
    value: float
    def __repr__(self) -> str:
        ...
class ValueSigmaAsuData:
    spacegroup: SpaceGroup
    unit_cell: UnitCell
    def __getitem__(self, index: int) -> ValueSigmaHklValue:
        ...
    def __init__(self, cell: UnitCell, sg: SpaceGroup, miller_array: numpy.ndarray, value_array: numpy.ndarray) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self) -> str:
        ...
    def copy(self) -> ValueSigmaAsuData:
        ...
    def count_equal_values(self, arg0: ValueSigmaAsuData) -> int:
        ...
    def ensure_asu(self, tnt_asu: bool = False) -> None:
        ...
    def ensure_sorted(self) -> None:
        ...
    def make_1_d2_array(self) -> numpy.ndarray:
        ...
    def make_d_array(self) -> numpy.ndarray:
        ...
    @property
    def miller_array(self) -> numpy.ndarray:
        ...
    @property
    def value_array(self) -> numpy.ndarray:
        ...
class ValueSigmaHklValue:
    value: ValueSigma
    def __repr__(self) -> str:
        ...
    @property
    def hkl(self) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
class Vec3:
    x: float
    y: float
    z: float
    def __add__(self, arg0: Vec3) -> Vec3:
        ...
    def __getitem__(self, arg0: int) -> float:
        ...
    def __iadd__(self, arg0: Vec3) -> Vec3:
        ...
    def __imul__(self, arg0: float) -> Vec3:
        ...
    def __init__(self, arg0: float, arg1: float, arg2: float) -> None:
        ...
    def __isub__(self, arg0: Vec3) -> Vec3:
        ...
    def __itruediv__(self, arg0: float) -> Vec3:
        ...
    def __mul__(self, arg0: float) -> Vec3:
        ...
    def __neg__(self) -> Vec3:
        ...
    def __repr__(self) -> str:
        ...
    def __rmul__(self, arg0: float) -> Vec3:
        ...
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
    def __sub__(self, arg0: Vec3) -> Vec3:
        ...
    def __truediv__(self, arg0: float) -> Vec3:
        ...
    def approx(self, other: Vec3, epsilon: float) -> bool:
        ...
    def cross(self, arg0: Vec3) -> Vec3:
        ...
    def dot(self, arg0: Vec3) -> float:
        ...
    def fromlist(self, arg0: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]) -> None:
        ...
    def length(self) -> float:
        ...
    def normalized(self) -> Vec3:
        ...
    def tolist(self) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(3)]:
        ...
class VectorMarkPtr:
    __hash__: typing.ClassVar[None] = None
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: NeighborSearch.Mark) -> bool:
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: VectorMarkPtr) -> bool:
        ...
    @typing.overload
    def __getitem__(self, s: slice) -> VectorMarkPtr:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> NeighborSearch.Mark:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: VectorMarkPtr) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __ne__(self, arg0: VectorMarkPtr) -> bool:
        ...
    def __repr__(self) -> str:
        """
        Return the canonical string representation of this list.
        """
    @typing.overload
    def __setitem__(self, arg0: int, arg1: NeighborSearch.Mark) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: VectorMarkPtr) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: NeighborSearch.Mark) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    def count(self, x: NeighborSearch.Mark) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: VectorMarkPtr) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: NeighborSearch.Mark) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> NeighborSearch.Mark:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> NeighborSearch.Mark:
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: NeighborSearch.Mark) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
def IT92_get_exact(arg0: Element, arg1: int) -> IT92Coef:
    ...
def IT92_get_ignore_charge() -> bool:
    ...
def IT92_normalize() -> None:
    ...
def IT92_set_ignore_charge(arg0: bool) -> None:
    ...
def add_automatic_links(arg0: Model, arg1: Structure, arg2: MonLib) -> None:
    ...
def add_chemcomp_to_block(arg0: ChemComp, arg1: cif.Block) -> None:
    ...
def adp_symmetry_constraints(arg0: SpaceGroup) -> list[typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(6)]]:
    ...
def align_sequence_to_polymer(full_seq: list[str], polymer: ResidueSpan, polymer_type: PolymerType, scoring: AlignmentScoring = None) -> AlignmentResult:
    ...
def align_string_sequences(query: list[str], target: list[str], target_gapo: list[int], scoring: AlignmentScoring = None) -> AlignmentResult:
    ...
def as_refln_blocks(arg0: cif.Document) -> ReflnBlocks:
    ...
def bessel_i1_over_i0(arg0: numpy.ndarray) -> typing.Any:
    ...
def bincorr(nbins: numpy.ndarray, obs: numpy.ndarray, calc: numpy.ndarray) -> list[Correlation]:
    ...
def binmean(nbins: numpy.ndarray, values: numpy.ndarray) -> numpy.ndarray:
    ...
def binrfactor(nbins: numpy.ndarray, obs: numpy.ndarray, calc: numpy.ndarray, riso: bool = False) -> numpy.ndarray:
    ...
def calculate_amplitude_normalizers(arg0: Mtz, arg1: str, arg2: Binner) -> numpy.ndarray:
    ...
def calculate_angle(arg0: Position, arg1: Position, arg2: Position) -> float:
    """
    Input: three points. Output: angle in radians.
    """
def calculate_b_est(arg0: Atom) -> float:
    ...
def calculate_current_rmsd(fixed: ResidueSpan, movable: ResidueSpan, ptype: PolymerType, sel: SupSelect, altloc: str = '\x00') -> SupResult:
    ...
def calculate_dihedral(arg0: Position, arg1: Position, arg2: Position, arg3: Position) -> float:
    """
    Input: four points. Output: dihedral angle in radians.
    """
def calculate_omega(residue: Residue, next_residue: Residue) -> float:
    ...
def calculate_phi_psi(prev_residue: Residue, residue: Residue, next_residue: Residue) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(2)]:
    ...
def calculate_sequence_weight(sequence: list[str], unknown: float = 0.0) -> float:
    ...
def calculate_superposition(fixed: ResidueSpan, movable: ResidueSpan, ptype: PolymerType, sel: SupSelect, trim_cycles: int = 0, trim_cutoff: float = 2.0, altloc: str = '\x00') -> SupResult:
    ...
def calculate_superpositions_in_moving_window(fixed: ResidueSpan, movable: ResidueSpan, ptype: PolymerType, radius: float = 10.0) -> list[SupResult]:
    ...
@typing.overload
def check_data_type_under_symmetry(arg0: ReflnBlock) -> tuple[DataType, int]:
    ...
@typing.overload
def check_data_type_under_symmetry(arg0: Mtz) -> tuple[DataType, int]:
    ...
def combine_correlations(arg0: list[Correlation]) -> Correlation:
    ...
def count_reflections(cell: UnitCell, spacegroup: SpaceGroup, dmin: float, dmax: float = 0.0, unique: bool = True) -> int:
    ...
def cromer_liberman(z: int, energy: float) -> tuple[float, float]:
    ...
def estimate_uncompressed_size(path: str) -> int:
    """
    Returns uncompressed size of a .gz file (not always reliable)
    """
def expand_if_pdb_code(code: str, filetype: str = 'M') -> str:
    ...
def expand_ncs_model(arg0: Model, arg1: NcsOpList, arg2: HowToNameCopiedChain) -> Model:
    ...
def expand_one_letter(arg0: str, arg1: ResidueKind) -> str:
    ...
def expand_one_letter_sequence(arg0: str, arg1: ResidueKind) -> list[str]:
    ...
def expand_pdb_code_to_path(code: str, filetype: str, throw_if_unset: bool = False) -> str:
    ...
def find_asu_brick(arg0: SpaceGroup) -> AsuBrick:
    ...
def find_best_plane(atoms: list[Atom]) -> typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(4)]:
    ...
def find_blobs_by_flood_fill(grid: FloatGrid, cutoff: float, min_volume: float = 10.0, min_score: float = 15.0, min_peak: float = 0.0, negate: bool = False) -> list[Blob]:
    ...
def find_lattice_2fold_ops(reduced_cell: UnitCell, max_obliq: float) -> list[tuple[Op, float]]:
    ...
def find_lattice_symmetry(cell: UnitCell, centring: str, max_obliq: float) -> GroupOps:
    ...
def find_lattice_symmetry_r(arg0: UnitCell, arg1: float) -> GroupOps:
    ...
def find_spacegroup_by_name(hm: str, alpha: float = 0.0, gamma: float = 0.0) -> SpaceGroup:
    """
    Returns space-group with given name.
    """
def find_spacegroup_by_number(ccp4: int) -> SpaceGroup:
    """
    Returns space-group of given number.
    """
def find_spacegroup_by_ops(group_ops: GroupOps) -> SpaceGroup:
    """
    Returns space-group with identical operations.
    """
def find_tabulated_residue(name: str) -> ResidueInfo:
    """
    Find chemical component information in the internal table.
    """
def find_twin_laws(cell: UnitCell, sg: SpaceGroup, max_obliq: float, all_ops: bool) -> list[Op]:
    ...
def flood_fill_above(grid: FloatGrid, seeds: list[Position], threshold: float, negate: bool = False) -> Int8Grid:
    ...
def generators_from_hall(hall: str) -> GroupOps:
    """
    Parse Hall notation.
    """
def get_distance_from_plane(pos: Position, coeff: typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(4)]) -> float:
    ...
def get_spacegroup_reference_setting(number: int) -> SpaceGroup:
    ...
def hkl_cif_as_refln_block(block: cif.Block) -> ReflnBlock:
    ...
def interpolate_grid(dest: FloatGrid, src: FloatGrid, tr: Transform, order: int = 2) -> None:
    ...
def interpolate_grid_of_aligned_model2(dest: FloatGrid, src: FloatGrid, tr: Transform, dest_model: Model, radius: float, order: int = 2) -> None:
    ...
def is_pdb_code(arg0: str) -> bool:
    ...
def log_bessel_i0(arg0: numpy.ndarray) -> typing.Any:
    ...
def log_cosh(arg0: numpy.ndarray) -> typing.Any:
    ...
def make_address(arg0: Chain, arg1: Residue, arg2: Atom) -> AtomAddress:
    ...
def make_assembly(arg0: Assembly, arg1: Model, arg2: HowToNameCopiedChain) -> Model:
    ...
def make_chemcomp_from_block(arg0: cif.Block) -> ChemComp:
    ...
def make_miller_array(cell: UnitCell, spacegroup: SpaceGroup, dmin: float, dmax: float = 0.0, unique: bool = True) -> numpy.ndarray:
    ...
def make_small_structure_from_block(block: cif.Block) -> SmallStructure:
    """
    Takes CIF block and returns SmallStructure.
    """
def make_structure_from_block(block: cif.Block) -> Structure:
    """
    Takes mmCIF block and returns Structure.
    """
def make_structure_from_chemcomp_block(block: cif.Block) -> Structure:
    """
    CIF block from CCD or monomer library -> single-residue Structure.
    """
def make_triplet_part(xyz: typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(3)], w: int, style: str = 'x') -> str:
    """
    Make one of the three parts of a triplet.
    """
def merge_atoms_in_expanded_model(model: Model, cell: UnitCell, max_dist: float = 0.2, compare_serial: bool = True) -> None:
    ...
def mott_bethe_const() -> float:
    ...
def mx_to_sx_structure(st: Structure, n: int = 0) -> SmallStructure:
    ...
def one_letter_code(arg0: list[str]) -> str:
    ...
def parse_triplet(triplet: str) -> Op:
    """
    Parse coordinate triplet into gemmi.Op.
    """
def parse_triplet_part(s: str) -> typing.Annotated[list[int], pybind11_stubgen.typing_ext.FixedSize(4)]:
    """
    Parse one of the three parts of a triplet.
    """
def pdbx_one_letter_code(arg0: list[str], arg1: ResidueKind) -> str:
    ...
def prepare_refmac_crd(arg0: Structure, arg1: Topo, arg2: MonLib, arg3: HydrogenChange) -> cif.Document:
    ...
def prepare_topology(st: Structure, monlib: MonLib, model_index: int = 0, h_change: HydrogenChange = HydrogenChange.NoChange, reorder: bool = False, warnings: typing.Any = None, ignore_unknown_links: bool = False, use_cispeps: bool = False) -> Topo:
    ...
def read_ccp4_map(path: str, setup: bool = False) -> Ccp4Map:
    """
    Reads a CCP4 file, mode 2 (floating-point data).
    """
def read_ccp4_mask(path: str, setup: bool = False) -> Ccp4Mask:
    """
    Reads a CCP4 file, mode 0 (int8_t data, usually 0/1 masks).
    """
def read_monomer_lib(monomer_dir: str, resnames: list[str], libin: str = '', ignore_missing: bool = False) -> MonLib:
    ...
def read_mtz_file(path: str) -> Mtz:
    ...
def read_pdb(filename: str, max_line_length: int = 0, split_chain_on_ter: bool = False) -> Structure:
    ...
def read_pdb_string(s: str, max_line_length: int = 0, split_chain_on_ter: bool = False) -> Structure:
    """
    Reads a string as PDB file.
    """
def read_pir_or_fasta(arg0: str) -> list[FastaSeq]:
    ...
def read_small_structure(path: str) -> SmallStructure:
    """
    Reads a small molecule CIF file.
    """
def read_structure(path: str, merge_chain_parts: bool = True, format: CoorFormat = CoorFormat.Unknown, save_doc: cif.Document = None) -> Structure:
    """
    Reads a coordinate file into Structure.
    """
def seitz_to_op(arg0: typing.Annotated[list[typing.Annotated[list[float], pybind11_stubgen.typing_ext.FixedSize(4)]], pybind11_stubgen.typing_ext.FixedSize(4)]) -> Op:
    ...
def sequence_kind(arg0: PolymerType) -> ResidueKind:
    ...
def setup_for_crd(arg0: Structure) -> None:
    ...
def spacegroup_table() -> typing.Iterator:
    ...
def spacegroup_table_itb() -> typing.Iterator:
    ...
def superpose_positions(pos1: list[Position], pos2: list[Position], weight: list[float] = []) -> SupResult:
    ...
def symops_from_hall(hall: str) -> GroupOps:
    """
    Parse Hall notation.
    """
def transform_f_phi_grid_to_map(grid: ReciprocalComplexGrid) -> FloatGrid:
    ...
def transform_map_to_f_phi(map: FloatGrid, half_l: bool = False, use_scale: bool = True) -> ReciprocalComplexGrid:
    ...
__version__: str = '0.6.5'
hc: float = 12398.4197386209
